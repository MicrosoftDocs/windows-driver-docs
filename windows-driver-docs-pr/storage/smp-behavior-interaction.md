---
title: SMP Behavior and Interaction (Windows Drivers)
description: Learn more about SMP Behavior and Interaction.
ms.date: 10/14/2022
---

# SMP Behavior and Interaction

## Intrinsic Methods and Management Infrastructure APIs

Storage Management Provider (SMP) developers will work with intrinsic methods generated by Convert-MofToProvider.exe and Management Infrastructure (MI) APIs from the *mi.h* file to supply implementation of their SMP. Below are some notes regarding a few key intrinsic and MI methods.

- **EnumerateInstances** and **GetInstance**

  EnumerateInstances is called when there is a query for instances of a particular class. For example: The PowerShell cmdlet Get-\<Object\> maps to the corresponding WMI object’s EnumerateInstances method. This method should return all instances of the class via \<Object\>\_Post method. Since EnumerateInstances is called by WMI frequently, it should perform quickly. This is achieved through good cache management.

  GetInstance is called when a specific instance of a class is needed, for example (but not limited to):

  - When WMI infrastructure invokes any method of this class
  - When a WMI-based application directly calls this method
  - When an instance of the class is requested through Association classes

  The GetInstance method should only return the object specified via \<Object\>\_Post method. The identifier of the instance being queried, that is the “Key” as defined in MOF, which is usually the ObjectId, is retrieved through the InstanceName parameter. This method is called by WMI frequently and should complete quickly.

  For regular classes (StorageProvider, StorageSubsystem, PhysicalDisk, etc.), EnumerateInstances and GetInstance are mandatory. For the Association classes, EnumerateInstances, AssociatorInstances and ReferenceInstances are mandatory, while GetInstance is not.

- **\<Object\>\_Post** and **MI\_PostResult**

  To understand the difference between MI API method \<Object\>\_Post and MI\_PostResult, think of \<Object\>\_Post as returning a pointer to an output parameter and MI\_PostResult as a function-return value that indicates the execution status of the function.

  You must only call MI\_PostResult once per WMI method “context”, which can be found in the input parameters of each WMI method. “Context” is a pointer to WMI callbacks. Calling MI\_PostResult will destroy this pointer. Therefore, a WMI method should never be called in the body of another WMI method.

  \<Object\>\_Post, on the other hand, can be called more than once per WMI method context. This method is typically used in EnumerateInstances to return multiple objects.

- **Set\<Property\>** and **ModifyInstance**

  The intrinsic method ModifyInstance is not supported through the [Windows Storage Management API](/previous-versions/windows/desktop/stormgmt/windows-storage-management-api-portal). To modify properties of an object, the extrinsic method Set\<Property\> is used.

Refer to the MI API samples from the Windows 8 SDK for more information on intrinsic methods and MI APIs.

## Object Identification

SMP interfaces use the following two groups of properties for object identification:

- For scripting and programming: **ObjectId** and **UniqueId**

  ObjectId is an opaque identifier created and maintained for the use of the SMPs and their clients to track instance of objects. It is a mandatory property that is required to be globally unique, that is, no two objects should ever have the same ObjectId, even if they are managed by separate SMPs, or are on different storage subsystems.

  If an object is visible through two different paths (for example: there are two separate SMPs that point to the same storage subsystem) then the same object may appear with two different ObjectIds. To determine if two object instances are the same object, use the UniqueId property.

  UniqueId is a mandatory property that is used to uniquely identify an instance of a class within a global scope. This value should be the same between two instances of SMPs running on different management servers. Unlike ObjectId, UniqueId should be a value that is persisted by the storage subsystem rather than the storage management provider process.

  UniqueId can be any opaque value except where otherwise noted (for example: MSFT\_VirtualDisk).

- For display: **FriendlyName** and **Name**

  End users will utilize these two properties to identify an object. FriendlyName is a user-friendly string that is settable by end users, provided such operation is supported by the SMP. FriendlyName need not be unique. Two objects from a single storage subsystem can share the same FriendlyName, although this practice is discouraged.

  Name property is set by the SMP and cannot be modified by end users. The SMP supplies additional information in this property to assist end users identifying an object. Such information may cover technical aspect of the object. For example, the Name of a storage subsystem can be the IP or WWN of the subsystem. Name is usually unique in certain scope. For example, Name of a storage pool must be unique in the owning storage subsystem.

## Error Handling

There are three types of errors in SMP interfaces: [Windows Storage Management API](/previous-versions/windows/desktop/stormgmt/windows-storage-management-api-portal) (SM API) return codes, “Soft errors” and “Hard errors”.

SM API return codes refer to the error codes listed as return values for each of the SMP extrinsic methods. For example, “5” represents “Invalid Parameter”. These error codes are returned via MIReturn output parameter defined in the method structure generated by Convert-MofToProvider.exe. The value of MIReturn can be set through \<Object\> \_\<Method\>\_Set\_MIReturn defined in the corresponding object’s header file.

Extrinsic methods should always default to use SM API error codes when possible. When additional information needed, SMPs can use MSFT\_ExtendedStatus class to supply extra status information about an extrinsic method’s invocation. This approach is preferable to using soft errors for extrinsic methods.

Soft errors refer to error messages returned via the MSFT\_SoftError class. These errors are designed for intrinsic methods (EnumerateInstances, GetInstance and etc.) where it’s not possible to return SM API error codes. To return soft errors, instances of the soft error classes derived from MSFT\_SoftError should be constructed and returned through the “MI\_Instance error” parameter in MI\_WriteCimError method defined in *mi.h*. For example, to indicate “correct credential is needed” during storage array login, an instance of “MSFT\_SoftError\_NotAuthenticated” can be returned during EnumerateInstances calls on StorageSubsystem objects. Note that in the case of soft errors, a result of MI\_RESULT\_OK should still be posted through MI\_PostResult.

Hard errors refer to the errors defined in MI\_Result structure from *mi.h* file. These are errors returned by MI APIs. SMP should avoid directly surfacing these errors to storage management applications unless absolutely necessary. For example, in case of “invalid parameters”, SMPs should use MIReturn to surface SM API error code “5” – “Invalid Parameter” instead of relying on MI\_RESULT\_INVALID\_PARAMETER to be consumed by storage management application.

## Primordial Pool

A primordial pool, also known as the “available storage” pool, is where storage capacity is drawn and returned in the creation and deletion of concrete storage pools. Primordial pools cannot be created, deleted or modified.

SMPs must provide at least one primordial pool. When a Physical Disk is added to a concrete Storage Pool, the Physical Disk should still be considered as part of the primordial pool.

## Size Reporting

There two special cases to discuss for various size fields from Storage Pool objects: capacity from hot-spare drives and capacity from unhealthy drives.

Once a drive is appointed as a hot-spare drive, its capacity should be included in corresponding primordial pool’s AllocatedSize. However, the drive’s capacity should not be included in any concrete pool’s Size, even if the storage array supports devoting a hot-spare drive to a specific concrete pool. After a hot-spare drive is devoted to a particular concrete pool, the drive’s capacity should not be included in the concrete pool’s AllocatedSize until it actually replaces a used drive. When added to a concrete pool, CanPooled should be FALSE for the Physical Disk object of this hot-spare drive. An association should be created between this Physical Disk object and the concrete pool’s Storage Pool object.

Capacity from drives with HealthStatus of “Unhealthy” should not be included in any size fields from either primordial pool or concrete pool.

## Associations

SM API includes association classes that define relationships between storage objects. With these association classes, it’s easy to traverse through the storage object hierarchy to obtain related objects for a given object. In the case of Storage PowerShell module, cmdlet piping is achieved through association classes. For example, given a Virtual Disk object, users can obtain the Storage Pool that owns the Virtual Disk object through the following cmdlet:

```powershell
    PS> Get-VirtualDisk –FriendlyName MyVirtualDisk | Get-StoragePool
```

The rest of this section illustrates implementation of association classes. Methods in the notes are generated by Convert-MofToProvider.exe for each association class. The notes use XToY as an example association class; the pseudo code uses StoragePoolToVirtualDisk as an example.

- **EnumerateInstances** and **GetInstance**

```powershell
      - XToY\_EnumerateInstances returns association objects (XToY objects) for ALL X objects
    
    <!-- end list -->
    
        void MI_CALL SAMPLE_StoragePoolToVirtualDisk_EnumerateInstances( ... )
        {
            ...
        
        /** This method should return association objects for ALL Storage Pools. **/
        
            // for each storage pool
        
                // for each virtual disk that's associated with this storage pool
        
                    // create the StoragePoolToVirtualDisk association object
                    // set the storage pool object and virtual disk object to this association object
                    // post the association object
                
                // end for
        
            // end for
        
            ...
        }
```

- **AssociatorInstances**

```powershell
      - AssociatorInstances method returns regular objects instead of association objects
      - XToY\_AssociatorInstancesX should return all associated Y object(s) for the X specified
      - XToY\_AssociatorInstancesY should return all associated X object(s) for the Y specified
    
    <!-- end list -->
    
        void MI_CALL SAMPLE_StoragePoolToVirtualDisk_AssociatorInstancesStoragePool(...)
        {
            ...
        
        /** This method should return VIRTUAL DISK object(s) for the 
        STORAGE POOL specified. **/
        
            // for each virtual disk that's associated with this storage pool
        
                // create the virtual disk object
                // post the virtual disk object
                
            // end for
        
            ...
        }
        
        void MI_CALL SAMPLE_StoragePoolToVirtualDisk_AssociatorInstancesVirtualDisk(...)
        {
            ...
        
        /** This method should return STORAGE POOL object(s) for the 
        VIRTUAL DISK specified. **/
        
            // for each storage pool that's associated with this virtual disk
        
                // create the storage pool object
                // post the storage pool object
                
            // end for
        
            ...
        }
```

- **ReferenceInstances**

```powershell
      - ReferenceInstances is similar to AssociatorInstances except that these methods return association (XToY) objects instead of regular objects
      - XToY\_ReferenceInstancesX should return XToY object(s) for X specified
      - XToY\_ReferenceInstancesY should return YToX object(s) for Y specified
    
    <!-- end list -->
    
        void MI_CALL SAMPLE_StoragePoolToVirtualDisk_ReferenceInstancesStoragePool(...)
        {
            ...
        
        /** This method should return StoragePoolToVirtualDisk 
        ASSOCIATION object(s) for the STORAGE POOL specified. **/
        
            // for each virtual disk that's associated with this storage pool
        
                // create the StoragePoolToVirtualDisk association object
                // set the storage pool and virtual disk to this association object
                // post the association object
                
            // end for
        
        
            ...
        }
        
        void MI_CALL SAMPLE_StoragePoolToVirtualDisk_ReferenceInstancesVirtualDisk(...)
        {
            ...
        
        /** This method should return StoragePoolToVirtualDisk 
        ASSOCIATION object(s) for the VIRTUAL DISK specified. **/
        
            // for each storage pool that's associated with this virtual disk
        
                // create the StoragePoolToVirtualDisk association object
                // set the storage pool and virtual disk to this association object
                // post the association object
                
            // end for
        
            ...
        }
```

## Cache Management

The SMP should initialize a cache of storage objects when it is loaded. This ensures a quick response time when servicing API calls as objects can be directly retrieve from the SMP’s cache. This cache should be kept in sync with in-band object changes as well as out-of-band object changes.

In-band object changes include those made through the current SMP instance. For example, if a virtual disk is created via the current SMP instance, not only a new Virtual Disk object should be added to the cache, but the associated objects such as the owning Storage Pool and associated Target Port objects should be updated as well.

Out-of-band changes include those made through vendor proprietary tools and SMPs hosting on other machines. For example, if a virtual disk is created through vendor proprietary tools, an event should be sent from the storage subsystem to the SMP(s) to trigger a cache update.

SMP should also update the cache when Discover method from Storage Provider class is called. This method will be called by storage management application to reset and rebuild the cache on event such as service restart or system reboot.

If it is not feasible for the SMP to initialize the entire cache at start-up (due to too many objects, or because it cannot be done quickly), then only the Storage Provider and Storage Subsystem objects should be loaded into cache. Applications will look at the CurrentCacheLevel property on the Storage Subsystem object to know how deep the cache has been filled. The rest of the cache is loaded explicitly by the user or application through the Discover method.

## Asynchronous Operations

Any operation that takes longer than 30 seconds to complete must return a Storage Job object. Methods that contain a CreatedStorageJob output parameter are most likely to be of this type of operation. SMPs should implement all these methods as asynchronous operations and return Storage Job objects for them. A Storage Job object must be returned to the caller within 30 seconds; otherwise, the caller can timeout if it waits too long and still hasn’t received the Storage Job object.

Applications (or “WMI Client”) have the option to specify whether a method should be “RunAsJob” or not. The SM API that applications use contains this extra Boolean RunAsJob parameter, as well as the CreatedStorageJob output parameter; meanwhile, the corresponding methods in SMP interfaces only have CreatedStorageJob parameter. However, regardless the value of “RunAsJob”, SMPs should always return Storage Job objects for these methods.

The following scenarios illustrate the call sequence of asynchronous operations. CreateVirtualDisk is used as an example:

- If “RunAsJob” is set to TRUE

  When CreateVirtualDisk is invoked, SMPs should do initialization for the method, start a job in the storage subsystem and return a Storage Job object to the caller within 30 seconds. However, the storage subsystem can take any amount of time to complete the operation. The caller will poll status of the job during this time.

  Worker threads should be used to execute the jobs. For efficiency purpose, SMPs can update job status related attributes (for example, PercentComplete) only when the caller polls the status of that job.

- If “RunAsJob” is set to FALSE

  The caller will be blocked on CreateVirtualDisk method until the method returns. The blocking and polling and will be done automatically by the SM API itself. This type of caller is usually a non-user-interactive client (for example, a scripting tool) that prefers blocking mechanism.

  Since the only way to get information about a newly created object is through the association between this object and the corresponding Storage Job object, SMPs should keep a Storage Job object for at least 24 hours before removing it from the cache. For other operations that do not return a newly created object (for example, a DeleteObject operation), an association is not needed and the Storage Job object only needs to remain alive for 15 minutes.

In case of unexpected system restart on management consoles, SMPs should maintain a cache of StorageJob objects at a physical location, for example at the storage array, and reload the cache upon system restart.

## Provider Life Time Control

A SMP can be implemented as a coupled or decoupled provider. For the difference between these two types of providers, refer to WMI MSDN documentation.

A decoupled provider is loaded and hosted in a vendor specific process. This process is typically an always-running service.

Starting a provider can be time consuming as it involves reloading the cache. If your SMP startup requires more than a second or so to load, it is recommended to implement a decoupled provider which manages storage objects through a persistent cache. This will help increase the overall performance and responsiveness of applications which use the Windows SM API to manage your SMP.

The DecoupledHost sample from the Windows 8 SDK for provides additional details about decoupled providers.

## Indications

Application developers often want to know when an object’s state changes as it changes. This can be done by subscribing to WMI indications. Indications are a different kind of class; they are exposed asynchronously, sometimes out of band from any management operation, and do not persist. Instead of implementing the familiar intrinsic methods (i.e. EnumerateInstances / GetInstance), there are new methods which must be supported.

There are four types of indications:

- Arrival – This indication is used when a device or object instance is added to the subsystem. For example: Adding a new physical disk to the subsystem, or creating a virtual disk.
- Departure – This indication is used when a device or object instance is removed from the subsystem. For example: Removing a physical disk from the subsystem, or deleting a storage pool.
- Modify – This indication is used when an important property changes on an existing object. At a minimum, HealthStatus and OperationalStatus changes must trigger a Modify indication. Indicating a change in any other property related to the operating status of an object is strongly encouraged.
- Alert – This indication is used to alert the application to a potential issue. Currently, the only defined alert is for notifying when a thin provisioning threshold is reached.

To implement indications, there are two new intrinsic methods which must be implemented for each indication class:

- EnableIndication – A request to subscribe to the indication class has been made. The indicationContext should be saved away so that it is available to post in an indication at a later point in time.
- DisableIndication – There are no more subscribers to the indication class. Cleanup should occur and no more indications for this class should be posted. indicationContext is destroyed at this time.

## Deployment

SMPs are installed on selected “management servers”. These servers can be clustered to provide redundancy. Other servers access storage allocated to them via iSCSI or Fiber Channel. All these machines can be managed by servers that run File Server User Interface from Server Manager.

Storage vendors, however, are welcome to choose whichever deployment model that best fits their requirements.

## Security Model

SMP interface supports Single Sign-On (SSO) model using Windows security credentials.

In the SSO model, a user logs in to a “management machine” with his or her Windows credentials once and automatically gains access to all storage assets that he or she has access permission. There is no need for specifying additional credentials for storage subsystem log in.

The interface also enables storage administrators to manage access control on individual storage assets. For each storage asset, storage administrators may grant different access rights to any windows user through the GetSecurityDescriptor and SetSecurityDescriptor methods. As a result, SMPs, unlike the VDS model, can now receive requests from any type of user account.

To implement SSO model, an SMP must authenticate the Windows clients to the storage subsystem. The storage subsystem must persist the security descriptor information for each storage asset. To implement authentication, storage vendors have two choices:

- Authenticate in the subsystem (recommended)
- Authenticate in each SMP instance.

Both options require a trust relationship to be established between the SMP and the storage subsystem so that security descriptor and user identity information can be passed securely.

To implement seamless authentication and authorization on the storage subsystem, we recommend the link between the SMP and the storage subsystem to implement Kerberos, NTLM or SPNego. If the storage subsystem has a web server in place, the “NTLM over HTTP” protocol \[MS-NLMP\] may be more helpful. Storage vendors can choose to keep their proprietary protocol(s) to implement SSO model, but this is not recommended as it can result in more work or setup than implementing one of the Windows-supported authentication protocols.

To support the Windows security policy, the storage subsystem has to obtain the user’s “token information”, which includes the user’s Security Identifier (SID) and the SIDs of any groups the user is a member of. If the Kerberos, NTLM or SPNego protocol is implemented, the storage subsystem will get the user’s token information as part of the protocol. If a vendor's proprietary protocol is used between SMP and the storage subsystem, the storage subsystem can query the user’s token information from Active Directory via Lightweight Directory Access Protocol (LDAP) and look at the tokenGroupsGlobalAndUniversal attribute or Object-Sid attribute on the user’s account object.

With the user’s token information, to enforce the Windows security policy, the storage subsystem need to implement the Access Check algorithm described in \[MS-DTYP\].

If a storage vendor chooses not to support this SSO model, then it’s recommended that the SMP follows the security model from VDS – allowing only operations initiated from Administrator accounts. This check, however, must now be performed by the SMP itself.
