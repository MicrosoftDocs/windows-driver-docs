---
title: Checksum offload
description: Checksum offload usage, rules, and examples in NetAdapterCx
keywords:
- WDF Network Adapter Class Extension Offloads, NetAdapterCx hardware offloads, NetAdapterCx Offloads, NetAdapter Offloads, Checksum Offload
ms.date: 08/10/2020
ms.custom: Fe
---

# Checksum offload

NetAdapterCx supports offloading TCP/IP checksum tasks at run time.

Before the TCP/IP transport passes a [**NET_PACKET**](/windows-hardware/drivers/ddi/packet/ns-packet-_net_packet) structure to the client driver, it specifies the checksum information associated with the NET_PACKET in a [**NET_PACKET_CHECKSUM**](/windows-hardware/drivers/ddi/checksumtypes/ns-checksumtypes-_net_packet_checksum) packet extension.

The TCP/IP transport calculates the one's complement sum for the TCP/UDP pseudoheader before offloading the checksum calculation for a TCP/UDP packet, as described in [Offloading Checksum Tasks](../network/offloading-checksum-tasks.md).

Turning off checksum offloads when [Generic Segmentation Offload](gso-offload.md) (GSO) is enabled doesn't prevent the client driver from computing and inserting checksums in packets generated by the GSO feature. To completely disable checksum offloads you must also disable GSO.

## INF keywords for controlling checksum offload

NetAdapterCx checks the registry keywords and honors them when enabling the active offload capabilities. The driver doesn't need to take any further action.

The checksum keywords specified in [Using Registry Values to Enable and Disable Task Offloading](../network/using-registry-values-to-enable-and-disable-task-offloading.md) can be used to enable/disable the checksum offload with a registry key setting. Grouped keywords are not supported.

The keyword values must be of type [REG_SZ](/windows/win32/sysinfo/registry-value-types).

## Configuring checksum offload

Client drivers first advertise their hardware's checksum offload capabilities during net adapter initialization. This might occur within their [*EvtDevicePrepareHardware*](/windows-hardware/drivers/ddi/wdfdevice/nc-wdfdevice-evt_wdf_device_prepare_hardware) callback before starting a net adapter.

To configure transmit (Tx) checksum offload, the client driver:

1. Allocates a [**NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES**](/windows-hardware/drivers/ddi/netadapteroffload/ns-netadapteroffload-_net_adapter_offload_tx_checksum_capabilities) structure.

1. Calls [**NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES_INIT**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-net_adapter_offload_tx_checksum_capabilities_init) to initialize the structure.

1. Calls [**NetAdapterOffloadSetTxChecksumCapabilities**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netadapteroffloadsettxchecksumcapabilities) to register the structure with NetAdapterCx.
 
During the call to **NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES_INIT** the client driver provides a pointer to the [*EVT_NET_ADAPTER_OFFLOAD_SET_TX_CHECKSUM*](/windows-hardware/drivers/ddi/netadapteroffload/nc-netadapteroffload-evt_net_adapter_offload_set_tx_checksum) callback. The system invokes this callback later if active offload capabilities change.

To configure receive (Rx) checksum offload, the client driver:

1. Allocates a [**NET_ADAPTER_OFFLOAD_RX_CHECKSUM_CAPABILITIES**](/windows-hardware/drivers/ddi/netadapteroffload/ns-netadapteroffload-_net_adapter_offload_rx_checksum_capabilities) structure.

1. Calls [**NET_ADAPTER_OFFLOAD_RX_CHECKSUM_CAPABILITIES_INIT**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-net_adapter_offload_rx_checksum_capabilities_init) to initialize the structure.

1. Calls [**NetAdapterOffloadSetRxChecksumCapabilities**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netadapteroffloadsetrxchecksumcapabilities) to register the structure with NetAdapterCx.

During the call to **NET_ADAPTER_OFFLOAD_RX_CHECKSUM_CAPABILITIES_INIT** the client driver provides a pointer to the [*EVT_NET_ADAPTER_OFFLOAD_SET_RX_CHECKSUM*](/windows-hardware/drivers/ddi/netadapteroffload/nc-netadapteroffload-evt_net_adapter_offload_set_rx_checksum) callback. The system invokes this callback later if active offload capabilities change.

### Rules for indicating hardware transmit checksum capabilities

1. The Layer3Flags in the [**NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES**](/windows-hardware/drivers/ddi/netadapteroffload/ns-netadapteroffload-_net_adapter_offload_tx_checksum_capabilities) structure must be set. Setting the Layer4Flags is optional. Setting the Layer3Flags and Layer4Flags indicates the packets on which the NIC is capable of performing checksum offload.

1. The Layer3HeaderOffsetLimit and Layer4HeaderOffsetLimit in **NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES** are optional. If the OS sends a packet with a header offset greater than the limit specified, it won't request the NIC to calculate the checksum for that layer.

1. IP/TCP packets without options/extensions must be supported if options/extensions are supported.

### Rules for indicating hardware receive checksum capabilities

NetAdapterCx doesn't require the driver to advertise the hardware receive checksum capabilities. If checksum offload is enabled, the NIC should perform checksum offload on all the packets it can handle. If the NIC can't perform checksum offload on a packet, NetAdapterCx will offload it in software.

This example shows how a client driver might set up its hardware checksum offload capabilities:

```C++
VOID
MyAdapterSetOffloadCapabilities(
    NETADAPTER NetAdapter
)
{
    // Configure the hardware's Tx checksum offload capabilities
    NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES txChecksumOffloadCapabilities;

    auto const layer3Flags = NetAdapterOffloadLayer3FlagIPv4NoOptions |
        NetAdapterOffloadLayer3FlagIPv4WithOptions |
        NetAdapterOffloadLayer3FlagIPv6NoExtensions |
        NetAdapterOffloadLayer3FlagIPv6WithExtensions;

    auto const layer4Flags = NetAdapterOffloadLayer4FlagTcpNoOptions |
        NetAdapterOffloadLayer4FlagTcpWithOptions |
        NetAdapterOffloadLayer4FlagUdp;

    NET_ADAPTER_OFFLOAD_TX_CHECKSUM_CAPABILITIES_INIT(
        &txChecksumOffloadCapabilities,
        layer3Flags,
        EvtAdapterOffloadSetTxChecksum);

    txChecksumOffloadCapabilities.Layer4Flags = layer4Flags;

    txChecksumOffloadCapabilities.Layer4HeaderOffsetLimit = 127;

    // Set the current Tx checksum offload capabilities and register the callback for future changes in active capabilities
    NetAdapterOffloadSetTxChecksumCapabilities(NetAdapter,
        &txChecksumOffloadCapabilities);

    // Configure the hardware's Rx checksum offload capabilities
    NET_ADAPTER_OFFLOAD_RX_CHECKSUM_CAPABILITIES rxChecksumOffloadCapabilities;

    NET_ADAPTER_OFFLOAD_RX_CHECKSUM_CAPABILITIES_INIT(
        &rxChecksumOffloadCapabilities,
        EvtAdapterOffloadSetRxChecksum);

    // Set the current Rx checksum offload capabilities and register the callback for future changes in active capabilities
    NetAdapterOffloadSetRxChecksumCapabilities(NetAdapter,
        &rxChecksumOffloadCapabilities);
}
```

## Updating hardware offloads

If the TCP/IP stack or an overlying protocol driver requests a change to the net adapter's active capabilities, NetAdapterCx invokes the client driver's [*EVT_NET_ADAPTER_OFFLOAD_SET_TX_CHECKSUM*](/windows-hardware/drivers/ddi/netadapteroffload/nc-netadapteroffload-evt_net_adapter_offload_set_tx_checksum) or [*EVT_NET_ADAPTER_OFFLOAD_SET_RX_CHECKSUM*](/windows-hardware/drivers/ddi/netadapteroffload/nc-netadapteroffload-evt_net_adapter_offload_set_rx_checksum) callback that was registered during adapter initialization. In these functions, the system supplies updated capabilities in the NETOFFLOAD object which the client driver queries to update its offload capabilities.

Client drivers can call the following functions to determine which checksum offloads are enabled:

* [**NetOffloadIsTxChecksumIPv4Enabled**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netoffloadistxchecksumipv4enabled)
* [**NetOffloadIsTxChecksumTcpEnabled**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netoffloadistxchecksumtcpenabled)
* [**NetOffloadIsTxChecksumUdpEnabled**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netoffloadistxchecksumudpenabled)
* [**NetOffloadIsRxChecksumIPv4Enabled**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netoffloadisrxchecksumipv4enabled)
* [**NetOffloadIsRxChecksumTcpEnabled**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netoffloadisrxchecksumtcpenabled)
* [**NetOffloadIsRxChecksumUdpEnabled**](/windows-hardware/drivers/ddi/netadapteroffload/nf-netadapteroffload-netoffloadisrxchecksumudpenabled)

The following example shows how a client driver might update its Tx/Rx checksum offload capabilities:

```C++
VOID
MyEvtAdapterOffloadSetTxChecksum(
    NETADAPTER  NetAdapter,
    NETOFFLOAD  Offload
)
{
    PMY_NET_ADAPTER_CONTEXT adapterContext = MyGetNetAdapterContext(NetAdapter);

    // Store the updated information in the context
    adapterContext->TxHardwareIpChecksum = NetOffloadIsTxChecksumIPv4Enabled(Offload);
    adapterContext->TxHardwareTcpChecksum = NetOffloadIsTxChecksumTcpEnabled(Offload);
    adapterContext->TxHardwareUdpChecksum = NetOffloadIsTxChecksumUdpEnabled(Offload);

    // Update the new hardware Tx checksum offload capabilities
    MyUpdateHardwareChecksum(adapterContext);
}

VOID
MyEvtAdapterOffloadSetRxChecksum(
    NETADAPTER  NetAdapter,
    NETOFFLOAD  Offload
)
{
    PMY_NET_ADAPTER_CONTEXT adapterContext = MyGetNetAdapterContext(NetAdapter);

    // Store the updated information in the context
    adapterContext->RxHardwareIpChecksum = NetOffloadIsRxChecksumIPv4Enabled(Offload);
    adapterContext->RxHardwareTcpChecksum = NetOffloadIsRxChecksumTcpEnabled(Offload);
    adapterContext->RxHardwareUdpChecksum = NetOffloadIsRxChecksumUdpEnabled(Offload);

    // Update the new hardware Rx checksum offload capabilities
    MyUpdateHardwareChecksum(adapterContext);
}
```

## Transmit checksum processing

A client driver typically does the following checksum processing on the transmit path:

1. The client driver calls the [**NetExtensionGetPacketChecksum**](/windows-hardware/drivers/ddi/checksum/nf-checksum-netextensiongetpacketchecksum) function with the packet index to obtain a [**NET_PACKET_CHECKSUM**](/windows-hardware/drivers/ddi/checksumtypes/ns-checksumtypes-_net_packet_checksum) structure.

2. The client driver tests the layer-specific flags in the NET_PACKET_CHECKSUM structure.

    * If the flag is `NetPacketTxChecksumActionPassthrough`, the NIC shouldn't perform checksum operations in that layer.

    * If the flag is `NetPacketTxChecksumActionRequired`, the client driver should determine the protocol being used at that layer in that specific packet using the [**NET_PACKET_LAYOUT**](/windows-hardware/drivers/ddi/packet/ns-packet-_net_packet_layout) structure and indicate to the NIC which checksum it should calculate for the packet.

3. The client driver passes the packet to the NIC, which calculates the appropriate checksums for the packet.

## Receive checksum processing

Before indicating a [**NET_PACKET**](/windows-hardware/drivers/ddi/packet/ns-packet-_net_packet) structure for a receive packet on which it performs checksum tasks, the client driver validates the checksums and sets the appropriate flags in the [**NET_PACKET_CHECKSUM**](/windows-hardware/drivers/ddi/checksumtypes/ns-checksumtypes-_net_packet_checksum) structure.

The flags can be one of the following:

| Flag | Description |
| --- | --- |
| `NetPacketRxChecksumEvaluationNotChecked` | The NIC could not validate the checksum of the packet |
| `NetPacketRxChecksumEvaluationValid` | The checksum of the packet is valid |
| `NetPacketRxChecksumEvaluationInvalid` | The checksum of the packet is invalid |
