---
title: Codec Merit Validation
description: Codec merit validation
keywords:
- hardware codecs WDK AVStream , validating merit
- codecs WDK AVStream
- codecs WDK AVStream , merit validation
- codecs WDK AVStream , hardware
- codecs WDK AVStream , hardware, merit validation
ms.date: 06/16/2020
---

# Codec merit validation

To support KSPROPSETID\_OPMVideoOutput, implement the following methods:

- KSMETHOD\_OPMVIDEOOUTPUT\_STARTINITIALIZATION

    [IOPMVideoOutput::StartInitialization](/windows/win32/api/opmapi/nf-opmapi-iopmvideooutput-startinitialization) proxies to the driver via KSMETHOD\_OPMVIDEOOUTPUT\_STARTINITIALIZATION.

- KSMETHOD\_OPMVIDEOOUTPUT\_ENDINITIALIZATION

    [IOPMVideoOutput::FinishInitialization](/windows/win32/api/opmapi/nf-opmapi-iopmvideooutput-finishinitialization) proxies to the driver via KSMETHOD\_OPMVIDEOOUTPUT\_ENDINITIALIZATION.

- KSMETHOD\_OPMVIDEOOUTPUT\_GETINFORMATION

    [IOPMVideoOutput::GetInformation](/windows/win32/api/opmapi/nf-opmapi-iopmvideooutput-getinformation) proxies to the driver via KSMETHOD\_OPMVIDEOOUTPUT\_GETINFORMATION.

The remainder of this topic includes a sample implementation of these three methods.

To use this code, you must include the following header files:

```cpp
#include <initguid.h>
#include <ksopmapi.h>
#include "testcert.h"
#include <bcrypt.h>
#include <wincrypt.h>
```

*Testcert.h* is a sample test certificate, the contents of which are at the bottom of this topic. *Testcert.h* is for testing purposes only and will not work on release builds; you must obtain your own certificate for a production driver.

You must also add *Ksecdd.lib* to the TARGETLIBS section of your *Sources* file:

```makefile
$(DDK_LIB_PATH)\ksecdd.lib
```

The sample handlers follow:

```cpp
class CBaseKsFilter{
protected:

    OPM_RANDOM_NUMBER m_RandomNumber;  //  Generated by this driver during StartInitialization

    UCHAR m_AESKey[16];         //  AES key from FinishInitialization

    ULONG m_StatusSequenceNumber;
    ULONG m_CommandSequenceNumber;


    CBaseKsFilter(IN PKSFILTER Filter) :
        ,m_StatusSequenceNumber(0)
        ,m_CommandSequenceNumber(0)
    {
        RtlZeroMemory(&m_RandomNumber, sizeof(m_RandomNumber));
        RtlZeroMemory(m_AESKey, sizeof(m_AESKey));
    }

    static NTSTATUS OPMVideoOutputStartInitialization(
        __in PIRP pIrp,
        __in PKSMETHOD pKsMethod,
        __in PVOID pData
        );

    static NTSTATUS OPMVideoOutputFinishInitialization(
        __in PIRP pIrp,
        __in PKSMETHOD pKsMethod,
        __in PVOID pData
        );

    static NTSTATUS OPMVideoOutputGetInformation(
        __in PIRP pIrp,
        __in PKSMETHOD pKsMethod,
        __in PVOID pData
        );

};

// Microsoft provides merit value with certificate
// This value should match the MFTMerit value specified in the registry

DWORD dwCMerit = 0x10;


//  These calls must run at PASSIVE level because bcrypt APIs are not all supported
//  at higher than PASSIVE level
//
//  Some of the key manipulations below are not safe for general keys
//

//======================================
// Defines
//======================================
#define BYTE_REMAINDER              7
#define WORD_REMAINDER              15
#define PUBEXP_FOUR_MASK            0xff000000
#define PUBEXP_THREE_MASK           0x00ff0000
#define PUBEXP_TWO_MASK             0x0000ff00
#define FIRST_BIT_MASK              0x80

NTSTATUS
CBaseKsFilter::OPMVideoOutputStartInitialization(
    __in PIRP pIrp,
    __in PKSMETHOD pKsMethod,
    __in PVOID pData
    )
{
    PAGED_CODE();
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG ulCertSize = sizeof (OPM_RANDOM_NUMBER) + sizeof (TestCert);

    CBaseKsFilter* pFilter = reinterpret_cast <CBaseKsFilter*> ((PKSFILTER)(KsGetFilterFromIrp(pIrp))->Context);

    if (!pFilter) {
        Status = STATUS_INVALID_PARAMETER;
    }
    else if (ulOutputBufferLength == 0)
    {
        pIrp->IoStatus.Information = ulCertSize;
        Status = STATUS_BUFFER_OVERFLOW;
    }
    else if (ulOutputBufferLength < ulCertSize)
    {
        pIrp->IoStatus.Information = ulCertSize;
        Status = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        if (pData)
        {
            Status = BCryptGenRandom(NULL,  
                                     pFilter->m_RandomNumber.abRandomNumber,
                                     sizeof(pFilter->m_RandomNumber.abRandomNumber),
                                     BCRYPT_USE_SYSTEM_PREFERRED_RNG);

            if (STATUS_SUCCESS == Status) {
                RtlCopyMemory(pData,
                              &pFilter->m_RandomNumber,
                              sizeof (OPM_RANDOM_NUMBER));

                RtlCopyMemory(((PBYTE)pData + sizeof (OPM_RANDOM_NUMBER)),
                              TestCert,
                              sizeof (TestCert));

                pIrp->IoStatus.Information = ulCertSize;
                Status = STATUS_SUCCESS;
            }  // endif STATUS_SUCCESS
        } // endif pData
    } // end else
    return Status;
}

void
ReverseMemCopy(__out_bcount(cb) BYTE *pbDest, __in_bcount(cb) BYTE const *pbSource, DWORD cb)
{
    PAGED_CODE();
    for (DWORD i = 0; i < cb; i++) {
        pbDest[cb - 1 - i] = pbSource[i];
    }
}

//  Convert the key from the RSA format Certutil gave us to the new BCRYPT format
//  BCrypt does not support importing legacy private blobs in kernel mode
NTSTATUS
ConvertLegacyRsaPrivateKeyToBCryptBlob(
    __in_bcount(cbLegacyBlob) const UCHAR *pbLegacyBlob,
    __in    DWORD   cbLegacyBlob,
    __deref_out_bcount(*pcbResult) PBYTE *ppbOutput,
    __out   DWORD * pcbResult)
{

 PAGED_CODE();
    BCRYPT_RSAKEY_BLOB *pRsaBlob = NULL;
    DWORD cbRsaBlob;
    DWORD cbPublicExp;
    DWORD cbModulus;
    DWORD cbHalfModulus;
    RSAPUBKEY RsaPubKey;
    const UCHAR *pbSource;
    PUCHAR pbDest;

    RtlCopyMemory(&RsaPubKey, pbLegacyBlob, sizeof(RSAPUBKEY));

    //
    // Compute size of RSA blob.
    //

    // First count number of bytes in public key modulus

    cbModulus = (RsaPubKey.bitlen + BYTE_REMAINDER) / 8;

    // Private key contains 2 primes.  Calculate number of bytes in one.

    cbHalfModulus = (RsaPubKey.bitlen + WORD_REMAINDER) / 16;

    // Count number of bytes in the public exponent.

    cbPublicExp = ((RsaPubKey.pubexp & PUBEXP_FOUR_MASK) ? 4 :
                  ((RsaPubKey.pubexp & PUBEXP_THREE_MASK) ? 3 :
                  ((RsaPubKey.pubexp & PUBEXP_TWO_MASK) ? 2 : 1)));

    cbRsaBlob = sizeof(BCRYPT_RSAKEY_BLOB) +
                cbPublicExp +
                cbModulus +
                cbHalfModulus * 2;

    *pcbResult = cbRsaBlob;

    *ppbOutput = new(PagedPool) BYTE[*pcbResult];
    if(*ppbOutput == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Build the RSA blob.
    //

    RtlZeroMemory(*ppbOutput, *pcbResult);

    pRsaBlob = (BCRYPT_RSAKEY_BLOB *)*ppbOutput;

    pRsaBlob->Magic = BCRYPT_RSAPRIVATE_MAGIC;
    pRsaBlob->BitLength = RsaPubKey.bitlen;
    pRsaBlob->cbPublicExp = cbPublicExp;
    pRsaBlob->cbModulus = cbModulus;
    pRsaBlob->cbPrime1 = cbHalfModulus;
    pRsaBlob->cbPrime2 = cbHalfModulus;

    pbSource = pbLegacyBlob + sizeof(RSAPUBKEY);
    pbDest = (PBYTE)(pRsaBlob + 1);

    ReverseMemCopy(pbDest, (PBYTE)&RsaPubKey.pubexp, cbPublicExp);
    pbDest += cbPublicExp;

    ReverseMemCopy(pbDest, pbSource, cbModulus);
    pbSource += cbModulus;
    pbDest += cbModulus;

    ReverseMemCopy(pbDest, pbSource, cbHalfModulus);
    pbSource += cbHalfModulus;
    pbDest += cbHalfModulus;

    ReverseMemCopy(pbDest, pbSource, cbHalfModulus);

    return STATUS_SUCCESS;
}

NTSTATUS
CBaseKsFilter::OPMVideoOutputFinishInitialization(
    __in PIRP pIrp,
    __in PKSMETHOD pKsMethod,
    __in PVOID pData
    )
{
    PAGED_CODE();
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    BCRYPT_ALG_HANDLE hAlg = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    BCRYPT_OAEP_PADDING_INFO paddingInfo = {0};
    ULONG DecryptedLength = 0;
    PUCHAR DecryptedParams = NULL;

    typedef struct {
        GUID  guidCOPPRandom;
        GUID  guidKDI;
        DWORD StatusSeqStart;
        DWORD CommandSeqStart;
    } InitParams;

    paddingInfo.pszAlgId = BCRYPT_SHA512_ALGORITHM;


    CBaseKsFilter* pFilter = reinterpret_cast <CBaseKsFilter*> ((PKSFILTER)(KsGetFilterFromIrp(pIrp))->Context);

    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE != ulOutputBufferLength)
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    //
    //  Decrypt the input using our private key
    //
    if (Status == STATUS_SUCCESS)
    {
        Status = BCryptOpenAlgorithmProvider(&hAlg,
                                             BCRYPT_RSA_ALGORITHM,
                                             MS_PRIMITIVE_PROVIDER,
                                             0);
    }

    //
    //  Set the key
    //
    if (Status == STATUS_SUCCESS)
    {
        //  Our key is in the legacy format - need to append a BLOBHEADER
        PUCHAR pbData = NULL;
        DWORD cbData = 0;
        Status = ConvertLegacyRsaPrivateKeyToBCryptBlob(PrivateKey, sizeof(PrivateKey), &pbData, &cbData);
        if (STATUS_SUCCESS == Status)
        {
            Status = BCryptImportKeyPair(hAlg,
                                         NULL,
                                         BCRYPT_RSAPRIVATE_BLOB,
                                         &hKey,
                                         pbData,
                                         cbData,
                                         0);

            if (pbData) delete [] pbData;
        }
    }

    //
    //  Decrypt the data
    //
    if (Status == STATUS_SUCCESS)
    {
        Status = BCryptDecrypt(hKey,
                               (PUCHAR)pData,
                               OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE,
                               &paddingInfo,
                               NULL,
                               0,
                               NULL,
                               0,
                               &DecryptedLength,
                               BCRYPT_PAD_OAEP);
    }

    if (Status == STATUS_SUCCESS)
    {
        DecryptedParams = new (PagedPool) UCHAR[DecryptedLength];
        if (NULL == DecryptedParams) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS)
    {
         Status = BCryptDecrypt(hKey,
                               (PUCHAR)pData,
                               OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE,
                               &paddingInfo,
                               NULL,
                               0,
                               DecryptedParams,
                               DecryptedLength,
                               &DecryptedLength,
                               BCRYPT_PAD_OAEP);
    }

    //  Check the random number and save the key and sequence number info
    if (Status == STATUS_SUCCESS)
    {
        InitParams *Params = (InitParams *)DecryptedParams;
        if (!RtlEqualMemory(&pFilter->m_RandomNumber, &Params->guidCOPPRandom, sizeof(pFilter->m_RandomNumber)))
        {
            Status = STATUS_ACCESS_DENIED;
        } else {
            RtlCopyMemory(pFilter->m_AESKey, &Params->guidKDI, sizeof(pFilter->m_AESKey));
            pFilter->m_StatusSequenceNumber = Params->StatusSeqStart;
            pFilter->m_CommandSequenceNumber = Params->CommandSeqStart;
        }
    }

    //  Clean up
    if (hKey)
    {
        BCryptDestroyKey(hKey);
    }
    if (hAlg)
    {
        BCryptCloseAlgorithmProvider(hAlg, 0);
    }
    if (DecryptedParams) delete [] DecryptedParams;
    return Status;
}

//  Binary helpers

//  Lshift does a logical shift left by one bit
//  of bytes in lpbOpd and stores the result in lpbRes

void LShift(__in_bcount(OPM_OMAC_SIZE) const BYTE *lpbOpd,
            __out_bcount(OPM_OMAC_SIZE) BYTE *lpbRes)
{
    PAGED_CODE();
    for( ULONG i = 0; i < OPM_OMAC_SIZE; i++ )
    {
        lpbRes[i] = lpbOpd[i] << 1;
        if( i < OPM_OMAC_SIZE - 1 )
        {
            // Now grab top bit from next byte
            lpbRes[i] |= ( (unsigned char)lpbOpd[i+1] ) >> 7;
        }
    }
}


void XOR(__inout_bcount(cbSize) BYTE *lpbLHS,
         __in_bcount(cbSize) const BYTE *lpbRHS, DWORD cbSize = OPM_OMAC_SIZE )
{
    PAGED_CODE();
    for( DWORD i = 0; i < cbSize; i++ )
    {
        lpbLHS[i] ^= lpbRHS[i];
    }
}

#ifndef  AES_KEYSIZE_128
#define AES_KEYSIZE_128 (16)
#endif

//
//  Helper to generate OMAC1 signature using AES128
//
NTSTATUS GenerateSignData(__in_bcount(AES_KEYSIZE_128) PUCHAR Key,
                          __in_bcount(cb) PUCHAR pb,
                          ULONG cb,
                          __out_bcount(OPM_OMAC_SIZE) PUCHAR Tag)
{
    PAGED_CODE();
    NTSTATUS Status = STATUS_SUCCESS;
    BCRYPT_ALG_HANDLE hAlg = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    ULONG cbKeyObject = 0;
    ULONG cbData = 0;
    PUCHAR pbKeyObject = NULL;
    struct {
        BCRYPT_KEY_DATA_BLOB_HEADER Header;
        UCHAR Key[AES_KEYSIZE_128];
    } KeyBlob;
    KeyBlob.Header.dwMagic = BCRYPT_KEY_DATA_BLOB_MAGIC;
    KeyBlob.Header.dwVersion = BCRYPT_KEY_DATA_BLOB_VERSION1;
    KeyBlob.Header.cbKeyData = AES_KEYSIZE_128;
    RtlCopyMemory(KeyBlob.Key, Key, sizeof(KeyBlob.Key));

    BYTE rgbLU[OPM_OMAC_SIZE];
    BYTE rgbLU_1[OPM_OMAC_SIZE];
    BYTE rBuffer[OPM_OMAC_SIZE];

    if (STATUS_SUCCESS == Status) {
        Status = BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_AES_ALGORITHM, MS_PRIMITIVE_PROVIDER, 0);
    }
    //
    //  Get the size needed for the key data
    //
    if (STATUS_SUCCESS == Status) {
        Status = BCryptGetProperty(hAlg, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(ULONG), &cbData, 0);
    }
    //
    //  Allocate the key data object
    //
    if (STATUS_SUCCESS == Status) {
        pbKeyObject = new(PagedPool) BYTE[cbKeyObject];
        if (NULL == pbKeyObject) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    //  Set to CBC chain mode
    //
    if (STATUS_SUCCESS == Status) {
        Status =  BCryptSetProperty(hAlg, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    }

    //
    //  Set the key
    //
    if (STATUS_SUCCESS == Status) {
        Status = BCryptImportKey(hAlg,
                                 NULL,
                                 BCRYPT_KEY_DATA_BLOB,
                                 &hKey,
                                 pbKeyObject,
                                 cbKeyObject,
                                 (PUCHAR)&KeyBlob,
                                 sizeof(KeyBlob),
                                 0);
    }

    //
    //  Encrypt 0s
    //
    if (STATUS_SUCCESS == Status) {
        ULONG cbBuffer = sizeof(rBuffer);
        RtlZeroMemory(rBuffer, sizeof(rBuffer));
        Status = BCryptEncrypt(hKey, rBuffer, cbBuffer, NULL, NULL, 0,
                      rBuffer, sizeof(rBuffer), &cbBuffer, 0);
    }

    //
    //  Compute OMAC1 parameters
    //
    if (STATUS_SUCCESS == Status)
    {
        const BYTE bLU_ComputationConstant = 0x87;
        LPBYTE pbL = rBuffer;

        LShift( pbL, rgbLU );
        if( pbL[0] & 0x80 )
        {
            rgbLU[OPM_OMAC_SIZE - 1] ^= bLU_ComputationConstant;
        }
        LShift( rgbLU, rgbLU_1 );
        if( rgbLU[0] & FIRST_BIT_MASK )
        {
            rgbLU_1[OPM_OMAC_SIZE - 1] ^= bLU_ComputationConstant;
        }
    }

    //
    //  Generate the hash - first redo the key to restart the CBC
    //
    if (STATUS_SUCCESS == Status) {
        BCryptDestroyKey(hKey);
        hKey = NULL;
        Status = BCryptImportKey(hAlg,
                                 NULL,
                                 BCRYPT_KEY_DATA_BLOB,
                                 &hKey,
                                 pbKeyObject,
                                 cbKeyObject,
                                 (PUCHAR)&KeyBlob,
                                 sizeof(KeyBlob),
                                 0);
    }

    if (STATUS_SUCCESS == Status) {
        PUCHAR pbDataInCur = pb;
        cbData = cb;
        do
        {
            DWORD cbBuffer = 0;
            if( cbData > OPM_OMAC_SIZE )
            {
                RtlCopyMemory( rBuffer, pbDataInCur, OPM_OMAC_SIZE );

                Status = BCryptEncrypt(hKey, rBuffer, sizeof(rBuffer), NULL, NULL, 0,
                                       rBuffer, sizeof(rBuffer), &cbBuffer, 0);


                pbDataInCur += OPM_OMAC_SIZE;
                cbData -= OPM_OMAC_SIZE;
            }
            else
            {
                if( cbData == OPM_OMAC_SIZE )
                {
                    RtlCopyMemory( rBuffer, pbDataInCur, OPM_OMAC_SIZE );
                    XOR( rBuffer, rgbLU );
                }
                else
                {
                    RtlZeroMemory( rBuffer, OPM_OMAC_SIZE );
                    RtlCopyMemory( rBuffer, pbDataInCur, cbData );
                    rBuffer[ cbData ] = 0x80;

                    XOR( rBuffer, rgbLU_1 );
                }

                Status = BCryptEncrypt(hKey, rBuffer, sizeof(rBuffer), NULL, NULL, 0,
                                       Tag, OPM_OMAC_SIZE, &cbBuffer, 0);

                cbData = 0;
            }

        } while( STATUS_SUCCESS == Status && cbData > 0 );
    }

    //  Clean up
    if (hKey)
    {
        BCryptDestroyKey(hKey);
    }
    if (hAlg)
    {
        BCryptCloseAlgorithmProvider(hAlg, 0);
    }
    if (pbKeyObject) delete [] pbKeyObject;
    return Status;
}

NTSTATUS
CBaseKsFilter::OPMVideoOutputGetInformation(
    __in PIRP pIrp,
    __in PKSMETHOD pKsMethod,
    __in PVOID pData
    )
{
    PAGED_CODE();
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    OPM_GET_INFO_PARAMETERS *Parameters = (OPM_GET_INFO_PARAMETERS *)pData;
    OPM_GET_CODEC_INFO_PARAMETERS *CodecInfoParameters;
    OPM_RANDOM_NUMBER RandomNumber = {0};

    CBaseKsFilter* pFilter = reinterpret_cast <CBaseKsFilter*> ((PKSFILTER)(KsGetFilterFromIrp(pIrp))->Context);

    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_SUCCESS)
    {
        if (ulOutputBufferLength < max(sizeof(OPM_GET_INFO_PARAMETERS), sizeof(OPM_REQUESTED_INFORMATION)))
        {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    //  Check signature
    if (Status == STATUS_SUCCESS)
    {
        UCHAR Tag[OPM_OMAC_SIZE];
        Status = GenerateSignData(pFilter->m_AESKey,
                                  (PUCHAR)pData + OPM_OMAC_SIZE,
                                  sizeof(OPM_GET_INFO_PARAMETERS) - OPM_OMAC_SIZE,
                                  Tag);
        if (Status == STATUS_SUCCESS)
        {
            if (!RtlEqualMemory(Tag, &Parameters->omac, OPM_OMAC_SIZE))
            {
                Status = STATUS_INVALID_SIGNATURE;
            }
        }
    }

    //  Check the data - random number, sequence number and object name
    if (Status == STATUS_SUCCESS) {
        if (Parameters->ulSequenceNumber != pFilter->m_StatusSequenceNumber++)
        {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    //  Is it for us?
    if (Status == STATUS_SUCCESS) {
        RandomNumber = Parameters->rnRandomNumber;
        if (Parameters->guidInformation != OPM_GET_CODEC_INFO) {
            Status = STATUS_NOT_IMPLEMENTED;
        }
    }

    //  Check parameters

    if (Status == STATUS_SUCCESS) {
        CodecInfoParameters = (OPM_GET_CODEC_INFO_PARAMETERS *)Parameters->abParameters;
        if (Parameters->cbParametersSize > OPM_GET_INFORMATION_PARAMETERS_SIZE ||
            Parameters->cbParametersSize < sizeof(ULONG) ||
            Parameters->cbParametersSize - sizeof(ULONG) != CodecInfoParameters->cbVerifier
            ) {
            Status = STATUS_INVALID_PARAMETER;
        }
    }


 //  Check path

#ifndef  TWOCHAR_OFFSET
#define TWOCHAR_OFFSET (2)
#endif

    if (STATUS_SUCCESS == Status) {
        PWSTR pSymbolicLinkList = NULL;
        CodecInfoParameters = (OPM_GET_CODEC_INFO_PARAMETERS *)Parameters->abParameters;

    // Define parameters prior to calling IoGetDeviceInterfaces
    // Class interface GUID is decoder/encoder KS filter's interface GUID
    // PDO should be the device object of the device for which the driver
    // is the functional driver


 IoGetDeviceInterfaces( pInterfaceClassGuid,
    pPhysicalDeviceObject,
    0,
    &pSymbolicLinkList
    );

    // Loop through the pSymbolicLinkList and see if we have a match between any symbolic link name
    // and the caller-supplied path in CodecInfoParameters
    if (STATUS_SUCCESS == Status) {
        Status = STATUS_OBJECT_PATH_INVALID;
        for (; pSymbolicLinkList;) {
            PUNICODE_STRING pSymbolicLinkName = pSymbolicLinkList;
            // Skip the first two characters that distinguish user and kernel mode names
            if (CodecInfoParameters->cbVerifier == pSymbolicLinkName->Length && RtlEqualMemory(pSymbolicLinkName->Buffer + TWOCHAR_OFFSET,
                CodecInfoParameters->Verifier + TWOCHAR_OFFSET,
                CodecInfoParameters->cbVerifier - TWOCHAR_OFFSET)) {
                    Status = STATUS_SUCCESS;
                    Break;
                }
                pSymbolicLinkList += pSymbolickLinkName->Length + 1;
            }
            ExFreePool(pSymbolicLinkList);
        }
    }

    if (Status == STATUS_SUCCESS)
    {
        OPM_REQUESTED_INFORMATION* pParam = (OPM_REQUESTED_INFORMATION*)pData;
        RtlZeroMemory(pData, sizeof(OPM_REQUESTED_INFORMATION));

        OPM_GET_CODEC_INFO_INFORMATION *Info = (OPM_GET_CODEC_INFO_INFORMATION *)pParam->abRequestedInformation;

        Info->Merit = dwCMerit;
        Info->rnRandomNumber = RandomNumber;

        pParam->cbRequestedInformationSize = sizeof (OPM_GET_CODEC_INFO_INFORMATION);

        //  Sign it with the key we were given
        Status = GenerateSignData(pFilter->m_AESKey,
                                  (PUCHAR)pData + OPM_OMAC_SIZE,
                                  sizeof(OPM_REQUESTED_INFORMATION) - OPM_OMAC_SIZE,
                                  pParam->omac.abOMAC);
    }

    if (STATUS_SUCCESS == Status) {
        pIrp->IoStatus.Information = sizeof(OPM_REQUESTED_INFORMATION);
    }

    return Status;
}

DEFINE_KSMETHOD_TABLE(SHEDFilterMethodTable)
{
    DEFINE_KSMETHOD_ITEM
    (
        KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION,        // MethodId
        KSMETHOD_TYPE_WRITE,                                // Flags
        CBaseKsFilter::OPMVideoOutputStartInitialization,   // MethodHandler
        sizeof(KSMETHOD),                                   // MinMethod
        0,                                                  // MinData
        NULL                                                // SupportHandler
    ),

    DEFINE_KSMETHOD_ITEM
    (
        KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION,       // MethodId
        KSMETHOD_TYPE_READ,                                 // Flags
        CBaseKsFilter::OPMVideoOutputFinishInitialization,  // MethodHandler
        sizeof(KSMETHOD),                                   // MinMethod
        0,                                                  // MinData
        NULL                                                // SupportHandler
    ),

    DEFINE_KSMETHOD_ITEM
    (
        KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION,         // MethodId
        KSMETHOD_TYPE_MODIFY,                           // Flags
        CBaseKsFilter::OPMVideoOutputGetInformation,    // MethodHandler
        sizeof(KSMETHOD),                               // MinMethod
        0,                                              // MinData
        NULL                                            // SupportHandler
    )
};

DEFINE_KSMETHOD_SET_TABLE(SHEDFilterMethodSets)
{
    DEFINE_KSMETHOD_SET
    (
        &KSPROPSETID_OPMVideoOutput,                    // MethodSetGUID
        SIZEOF_ARRAY(SHEDFilterMethodTable),            // MethodCount
        SHEDFilterMethodTable,                          // MethodItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    )
};

DEFINE_KSAUTOMATION_TABLE(SHEDFilterAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES(SHEDFilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS(SHEDFilterMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};
```

*Testcert.h* appears as follows:

```cpp
#ifndef _TESTCERT_H_
#define _TESTCERT_H_

const BYTE PrivateKey[] = {

    0x52,0x53,0x41,0x32,0x00,0x08,0x00,0x00,0x01,0x00,0x01,0x00,0x71,0x16,0x51,0x99,
    0x5b,0x8a,0x9f,0x9a,0x6f,0x55,0x78,0x85,0x37,0x0c,0xce,0xeb,0x45,0xf1,0xc7,0x31,
    0x37,0x1b,0x11,0xaa,0xdc,0x45,0x0f,0xfd,0x35,0x3b,0x36,0x36,0xbf,0x0d,0x72,0xd9,
    0x2e,0x11,0x62,0xf6,0xc9,0x3f,0x1d,0x64,0xd0,0x3e,0x8d,0x2e,0x17,0xb6,0x0b,0xe5,
    0xd6,0x5b,0xa1,0x4e,0x61,0xed,0x63,0xfc,0x11,0x6e,0x5d,0x00,0x9d,0x00,0xe9,0xac,
    0x2f,0x8c,0xd5,0x30,0x13,0xcb,0x12,0xae,0xa2,0xb6,0xc8,0xb4,0x57,0x6c,0xfe,0xe6,
    0x36,0xbc,0xba,0x36,0xde,0x77,0x31,0x7a,0x0d,0x96,0x19,0x4c,0x18,0x3f,0x8f,0xf0,
    0x98,0xe5,0xcf,0x24,0x20,0x4d,0x8a,0x50,0x35,0xd7,0xe2,0x85,0x8f,0x08,0x24,0xcb,
    0x0b,0xd3,0xd6,0x58,0x9e,0xcf,0xa6,0x37,0xf5,0x07,0xb7,0x42,0x21,0x2c,0xb2,0x6b,
    0x11,0xef,0x34,0x1b,0x39,0x84,0xb6,0xc1,0x34,0x51,0xfd,0x8a,0x37,0x73,0x28,0x31,
    0x4b,0x06,0x70,0xd1,0xfd,0x0f,0x9a,0x76,0x9d,0x4d,0x93,0x60,0x53,0x4c,0x84,0x8f,
    0x63,0xab,0x4b,0xa2,0x7a,0xfd,0xd4,0x98,0xc5,0x7a,0x01,0xc8,0xaf,0x4b,0x0a,0xea,
    0xff,0x9c,0x23,0xb9,0xde,0x35,0xbc,0xfc,0x68,0xf7,0x0f,0x8a,0xf1,0x25,0x68,0x1e,
    0xb6,0x2f,0x78,0x0b,0x85,0x5f,0xbd,0xd2,0x87,0x8f,0x3f,0xff,0xd1,0x06,0x7e,0x5c,
    0xab,0x01,0x38,0x07,0x2f,0x74,0x36,0xfe,0xe6,0xce,0x91,0x2a,0xd1,0x78,0x73,0x79,
    0x13,0x7c,0xa4,0x2b,0x3f,0xac,0xd3,0x7f,0x3f,0xee,0xfa,0x4e,0x94,0x82,0x68,0xf0,
    0x0e,0x09,0x95,0xea,0x3d,0x24,0x1a,0x1e,0xc2,0xdc,0x73,0xd3,0x4d,0xa5,0xf1,0xcc,
    0xd9,0xc6,0x4e,0xe5,0xfc,0xb1,0xf3,0x66,0x05,0x87,0x99,0xfa,0x1e,0xb0,0x79,0x40,
    0x85,0xf9,0xf3,0x76,0xd4,0xad,0xb2,0x7a,0x6a,0x5b,0x6a,0x2b,0x4a,0x4f,0x7b,0xb9,
    0x26,0x88,0x54,0xb8,0xd1,0x3d,0x6e,0x53,0xc6,0x22,0x55,0x51,0x48,0xb1,0xe2,0x59,
    0xc0,0x0f,0x0c,0xdf,0x98,0x5b,0xc3,0xef,0x70,0xde,0xf4,0xb8,0x9e,0xbd,0x84,0x9b,
    0xc4,0x93,0xb7,0xad,0xed,0x86,0x43,0x8f,0x16,0x6e,0x9e,0x7d,0xc9,0x1b,0x3d,0x30,
    0x48,0x8e,0x9a,0x43,0xdf,0x00,0x9a,0x77,0x4a,0x63,0xad,0xf1,0x51,0xf1,0x0b,0xf8,
    0x4c,0x45,0x90,0xd1,0xe0,0x7b,0x8a,0x8e,0x5a,0xe2,0x59,0x21,0x02,0xb5,0x4d,0xdf,
    0xe7,0x05,0x62,0xff,0x40,0x45,0x5a,0xdd,0xa1,0x9e,0xe7,0xea,0xb5,0x93,0xbc,0xbc,
    0xa9,0x77,0x21,0x29,0x83,0x81,0x4b,0x6d,0x4d,0x9e,0x21,0xb9,0x92,0x11,0x14,0x06,
    0xdf,0x94,0xcf,0x8a,0x90,0xe0,0x03,0xf3,0x05,0xb9,0xb8,0x47,0xda,0x73,0x5a,0xbc,
    0x9a,0x38,0xcb,0x23,0x6f,0x37,0x1a,0x4f,0xb1,0x17,0x32,0x7d,0x61,0x4a,0x12,0xf8,
    0x82,0xbd,0xbb,0xd7,0x09,0xda,0xf4,0xc4,0x77,0x81,0x4d,0x81,0x4e,0x08,0xe9,0xe4,
    0xb4,0xc0,0x02,0x8e,0x1d,0x89,0x07,0x39,0xb0,0x45,0x40,0x0f,0x3f,0xd4,0xe5,0xa1,
    0x7f,0xe2,0xd9,0x61,0xd1,0xfd,0xfa,0x82,0xf4,0xf5,0x9a,0xdd,0x47,0x74,0x51,0xf1,
    0xc3,0x99,0x71,0x66,0x78,0xa1,0x07,0x73,0x3b,0x92,0xeb,0xe5,0x27,0x07,0xd7,0x39,
    0x71,0xe0,0x1f,0x21,0x70,0x91,0x45,0x6f,0xcb,0x15,0x71,0xe6,0x55,0x16,0xfd,0x7c,
    0xae,0xc8,0x38,0x94,0x54,0x93,0x52,0xf9,0x7d,0xcd,0x30,0x79,0x32,0x34,0x64,0x95,
    0xa3,0x63,0x8e,0xa6,0x82,0xfd,0x23,0x8c,0x5c,0xe9,0x37,0x36,0x66,0x8d,0xc9,0xc9,
    0xfd,0xc2,0xd4,0xc5,0x37,0x49,0x9e,0x2a,0x37,0x2f,0xe1,0x95,0xfc,0x61,0xa1,0xe7,
    0xa2,0x7b,0xec,0x75,0xf5,0xc7,0x06,0x4d,0x6d,0x46,0x1b,0x9d,0x5a,0x4a,0xe7,0xe3,
    0xa5,0xa9,0x64,0x82,0xa9,0xc6,0x06,0x7b,0x52,0xec,0xf6,0x2c,0x40,0x85,0x5d,0x5c,
    0x3c,0x50,0x49,0x17,0x2c,0x2d,0x94,0x4b,0x76,0xd2,0xc0,0x07,0xa7,0x82,0x25,0x08,
    0x24,0x9d,0xea,0xd9,0xe1,0xe2,0xb7,0x56,0x1a,0xdc,0x1e,0x7f,0x1f,0x0b,0xf0,0x53,
    0xb7,0xe4,0xf4,0x32,0x24,0x2e,0xce,0xa3,0xf0,0x72,0x78,0x2c,0xc9,0x6f,0x33,0x21,
    0x57,0x0f,0x94,0xaf,0x7a,0x1d,0x48,0xd5,0xae,0xd2,0x66,0x93,0x82,0xbc,0x47,0xd8,
    0x1e,0x0c,0x23,0x37,0x3b,0x57,0xd8,0x2e,0x9b,0x15,0x65,0x02,0xcc,0x46,0x94,0x17,
    0xbe,0x4a,0x7f,0x13,0x0a,0xbf,0xa1,0xc3,0x63,0x14,0xd5,0xc7,0x9c,0x90,0xc2,0x03,
    0x33,0x58,0x10,0xef,0x3b,0xc8,0x7b,0x08,0xc1,0xa7,0xf3,0x31,0x33,0x2d,0x61,0xb2,
    0xda,0x59,0xd6,0xd4,0x51,0xf0,0x71,0x9f,0x01,0xf1,0x6a,0x20,0x6f,0x99,0x0f,0xc0,
    0x7c,0x9f,0xee,0x02,0xd1,0x63,0x65,0x1c,0x2d,0xfe,0xd3,0x10,0x1b,0x8b,0x0f,0x6a,
    0x9f,0xd6,0xbe,0xd6,0x70,0x37,0xd7,0x00,0x9c,0x99,0x80,0x38,0xb9,0x83,0x10,0x87,
    0x83,0x38,0xe2,0x6a,0xa2,0x7a,0x38,0x52,0x28,0x6a,0xbc,0x2a,0xe9,0x97,0xbb,0xf3,
    0x49,0x19,0x55,0xfe,0x26,0x9f,0x02,0x39,0xd7,0xd6,0x4b,0xe0,0x92,0x4e,0x34,0x9e,
    0x55,0x02,0x7f,0x6b,0xd6,0x78,0xfa,0xcb,0x16,0x5d,0x6c,0x3e,0x43,0x9d,0xa8,0x08,
    0x0b,0x72,0x80,0xf0,0xaa,0xcd,0x50,0x31,0xc1,0x82,0xfa,0xe5,0xdc,0x24,0x76,0x22,
    0xee,0xce,0xd0,0xff,0xf9,0x11,0x4f,0xfb,0xd4,0x8a,0x5d,0x2f,0xa5,0x02,0xdb,0xc1,
    0x6e,0x41,0x35,0x77,0xe4,0x12,0xc7,0x9f,0x1d,0x92,0x5f,0x41,0x3b,0xa4,0x45,0x7a,
    0x4c,0x73,0x89,0x8c,0x99,0x0a,0x61,0xc9,0x12,0xad,0xdd,0xd1,0xcb,0x4f,0x05,0x96,
    0xd5,0x6f,0x68,0x74,0x88,0xbb,0xca,0x9a,0x27,0x6d,0x7a,0x0b,0x2c,0x6a,0x05,0x70,
    0x49,0xbb,0x6f,0x7f,0x64,0xa9,0x5d,0x69,0x46,0xa4,0xc6,0x12,0x11,0x7a,0xff,0x7d,
    0x54,0xf4,0x99,0x2c,0x6e,0xc2,0x76,0x86,0xe2,0x0e,0x1a,0x31,0x0b,0x52,0x5e,0x25,
    0x43,0xdc,0xe5,0xc8,0x68,0xd9,0xad,0xe0,0xfd,0x9f,0xcd,0x32,0xa5,0x65,0x67,0x45,
    0xe2,0xdc,0xbb,0x60,0xa6,0x1c,0xd0,0xf1,0x31,0x3c,0xdd,0xef,0x18,0x98,0xf4,0x3d,
    0x30,0x8f,0xf5,0x19,0x8b,0xfb,0x96,0x52,0x4c,0x50,0x7a,0x0f,0x12,0x02,0x61,0x66,
    0x24,0x6b,0x69,0x01,0xd1,0x94,0x61,0x17,0x40,0x75,0xe8,0xa2,0xa1,0xf3,0x68,0x8d,
    0x45,0x59,0x00,0x42,0xb0,0x71,0x98,0x01,0x24,0x69,0x5a,0x01,0xf1,0xad,0x6c,0xcb,
    0xf2,0x3c,0xc7,0xf2,0xaa,0x2c,0x75,0x06,0xd2,0xa3,0xb0,0x9d,0xd5,0xb0,0xd5,0x9c,
    0xb7,0x16,0x1a,0x2a,0xc0,0x2f,0x8c,0x9f,0x43,0xc1,0x66,0x29,0x81,0xe6,0xdf,0xf9,
    0xa1,0xe4,0x86,0x68,0xc1,0x64,0xbe,0xba,0x4a,0x88,0x42,0xc6,0xa1,0x2b,0xf0,0x18,
    0x55,0x67,0x4d,0xbf,0xe8,0x7d,0x41,0x3e,0x12,0x6e,0xc1,0x96,0x0b,0x12,0x81,0x9e,
    0x00,0xdc,0x61,0xf3,0x35,0x5e,0xa2,0x27,0xe6,0xa5,0x8a,0xf4,0x2d,0xd4,0x79,0x01,
    0x87,0x87,0x74,0x04,0xf3,0xee,0x16,0x12,0xbc,0xfa,0xeb,0xbe,0x78,0x7a,0xd2,0x4f,
    0x6b,0x48,0x33,0xb2,0xba,0xbf,0x5f,0xb6,0x3a,0x4c,0x4b,0x34,0xe1,0x8d,0xaf,0x6b,
    0x26,0x70,0x88,0x98,0x28,0xda,0x61,0x8b,0x85,0x97,0x81,0x50,0x54,0xfc,0x8c,0x12,
    0xc3,0x16,0x01,0xcb,0x6f,0xa7,0xbe,0xd0,0x59,0xf7,0xa5,0x7b,0x94,0x0e,0x23,0x02,
    0x9b,0xd8,0x8a,0x9a,0xb4,0x02,0xcd,0xaf,0xbd,0xfa,0x39,0x13
};


const BYTE TestCert[] =
{
    0x30,0x82,0x0c,0x38,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x07,0x02,0xa0,
    0x82,0x0c,0x29,0x30,0x82,0x0c,0x25,0x02,0x01,0x01,0x31,0x00,0x30,0x0b,0x06,0x09,
    0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x07,0x01,0xa0,0x82,0x0c,0x0d,0x30,0x82,0x04,
    0xb3,0x30,0x82,0x03,0x9b,0xa0,0x03,0x02,0x01,0x02,0x02,0x0a,0x12,0xd8,0xa8,0x41,
    0x00,0x00,0x00,0x00,0x00,0x03,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,
    0x01,0x01,0x05,0x05,0x00,0x30,0x7a,0x31,0x13,0x30,0x11,0x06,0x0a,0x09,0x92,0x26,
    0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x03,0x63,0x6f,0x6d,0x31,0x19,0x30,0x17,
    0x06,0x0a,0x09,0x92,0x26,0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x09,0x6d,0x69,
    0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x31,0x14,0x30,0x12,0x06,0x0a,0x09,0x92,0x26,
    0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x04,0x63,0x6f,0x72,0x70,0x31,0x17,0x30,
    0x15,0x06,0x0a,0x09,0x92,0x26,0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x07,0x72,
    0x65,0x64,0x6d,0x6f,0x6e,0x64,0x31,0x19,0x30,0x17,0x06,0x03,0x55,0x04,0x03,0x13,
    0x10,0x53,0x48,0x45,0x44,0x56,0x65,0x6e,0x64,0x6f,0x72,0x54,0x65,0x73,0x74,0x43,
    0x41,0x30,0x1e,0x17,0x0d,0x30,0x38,0x30,0x34,0x32,0x35,0x31,0x34,0x31,0x32,0x34,
    0x30,0x5a,0x17,0x0d,0x30,0x39,0x30,0x34,0x32,0x35,0x30,0x33,0x34,0x35,0x30,0x39,
    0x5a,0x30,0x20,0x31,0x1e,0x30,0x1c,0x06,0x03,0x55,0x04,0x03,0x13,0x15,0x53,0x48,
    0x45,0x44,0x20,0x56,0x65,0x6e,0x64,0x6f,0x72,0x20,0x50,0x72,0x6f,0x64,0x75,0x63,
    0x74,0x20,0x31,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,
    0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,
    0x82,0x01,0x01,0x00,0xd3,0x73,0xdc,0xc2,0x1e,0x1a,0x24,0x3d,0xea,0x95,0x09,0x0e,
    0xf0,0x68,0x82,0x94,0x4e,0xfa,0xee,0x3f,0x7f,0xd3,0xac,0x3f,0x2b,0xa4,0x7c,0x13,
    0x79,0x73,0x78,0xd1,0x2a,0x91,0xce,0xe6,0xfe,0x36,0x74,0x2f,0x07,0x38,0x01,0xab,
    0x5c,0x7e,0x06,0xd1,0xff,0x3f,0x8f,0x87,0xd2,0xbd,0x5f,0x85,0x0b,0x78,0x2f,0xb6,
    0x1e,0x68,0x25,0xf1,0x8a,0x0f,0xf7,0x68,0xfc,0xbc,0x35,0xde,0xb9,0x23,0x9c,0xff,
    0xea,0x0a,0x4b,0xaf,0xc8,0x01,0x7a,0xc5,0x98,0xd4,0xfd,0x7a,0xa2,0x4b,0xab,0x63,
    0x8f,0x84,0x4c,0x53,0x60,0x93,0x4d,0x9d,0x76,0x9a,0x0f,0xfd,0xd1,0x70,0x06,0x4b,
    0x31,0x28,0x73,0x37,0x8a,0xfd,0x51,0x34,0xc1,0xb6,0x84,0x39,0x1b,0x34,0xef,0x11,
    0x6b,0xb2,0x2c,0x21,0x42,0xb7,0x07,0xf5,0x37,0xa6,0xcf,0x9e,0x58,0xd6,0xd3,0x0b,
    0xcb,0x24,0x08,0x8f,0x85,0xe2,0xd7,0x35,0x50,0x8a,0x4d,0x20,0x24,0xcf,0xe5,0x98,
    0xf0,0x8f,0x3f,0x18,0x4c,0x19,0x96,0x0d,0x7a,0x31,0x77,0xde,0x36,0xba,0xbc,0x36,
    0xe6,0xfe,0x6c,0x57,0xb4,0xc8,0xb6,0xa2,0xae,0x12,0xcb,0x13,0x30,0xd5,0x8c,0x2f,
    0xac,0xe9,0x00,0x9d,0x00,0x5d,0x6e,0x11,0xfc,0x63,0xed,0x61,0x4e,0xa1,0x5b,0xd6,
    0xe5,0x0b,0xb6,0x17,0x2e,0x8d,0x3e,0xd0,0x64,0x1d,0x3f,0xc9,0xf6,0x62,0x11,0x2e,
    0xd9,0x72,0x0d,0xbf,0x36,0x36,0x3b,0x35,0xfd,0x0f,0x45,0xdc,0xaa,0x11,0x1b,0x37,
    0x31,0xc7,0xf1,0x45,0xeb,0xce,0x0c,0x37,0x85,0x78,0x55,0x6f,0x9a,0x9f,0x8a,0x5b,
    0x99,0x51,0x16,0x71,0x02,0x03,0x01,0x00,0x01,0xa3,0x82,0x01,0x93,0x30,0x82,0x01,
    0x8f,0x30,0x0e,0x06,0x03,0x55,0x1d,0x0f,0x01,0x01,0xff,0x04,0x04,0x03,0x02,0x06,
    0xc0,0x30,0x1d,0x06,0x03,0x55,0x1d,0x0e,0x04,0x16,0x04,0x14,0xcd,0x74,0x1d,0x39,
    0x5a,0x72,0x84,0x5e,0xa0,0x3d,0x4a,0x37,0x89,0xfe,0xb6,0x2a,0xf9,0xc1,0x5f,0x43,
    0x30,0x1f,0x06,0x03,0x55,0x1d,0x25,0x04,0x18,0x30,0x16,0x06,0x0a,0x2b,0x06,0x01,
    0x04,0x01,0x82,0x37,0x0a,0x05,0x0a,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x03,
    0x03,0x30,0x1f,0x06,0x03,0x55,0x1d,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0x97,0xf8,
    0x87,0x7c,0xd3,0x45,0xb8,0x0a,0xff,0x63,0xc5,0xdf,0x50,0x13,0x6a,0xf7,0xa7,0x9d,
    0x50,0x79,0x30,0x82,0x01,0x1a,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x01,0x01,
    0x04,0x82,0x01,0x0c,0x30,0x82,0x01,0x08,0x30,0x81,0x80,0x06,0x08,0x2b,0x06,0x01,
    0x05,0x05,0x07,0x30,0x02,0x86,0x74,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x64,0x73,
    0x73,0x70,0x73,0x76,0x72,0x34,0x63,0x61,0x32,0x2e,0x72,0x65,0x64,0x6d,0x6f,0x6e,
    0x64,0x2e,0x63,0x6f,0x72,0x70,0x2e,0x6d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,
    0x2e,0x63,0x6f,0x6d,0x2f,0x43,0x65,0x72,0x74,0x45,0x6e,0x72,0x6f,0x6c,0x6c,0x2f,
    0x64,0x73,0x73,0x70,0x73,0x76,0x72,0x34,0x63,0x61,0x32,0x2e,0x72,0x65,0x64,0x6d,
    0x6f,0x6e,0x64,0x2e,0x63,0x6f,0x72,0x70,0x2e,0x6d,0x69,0x63,0x72,0x6f,0x73,0x6f,
    0x66,0x74,0x2e,0x63,0x6f,0x6d,0x5f,0x53,0x48,0x45,0x44,0x56,0x65,0x6e,0x64,0x6f,
    0x72,0x54,0x65,0x73,0x74,0x43,0x41,0x2e,0x63,0x72,0x74,0x30,0x81,0x82,0x06,0x08,
    0x2b,0x06,0x01,0x05,0x05,0x07,0x30,0x02,0x86,0x76,0x66,0x69,0x6c,0x65,0x3a,0x2f,
    0x2f,0x5c,0x5c,0x64,0x73,0x73,0x70,0x73,0x76,0x72,0x34,0x63,0x61,0x32,0x2e,0x72,
    0x65,0x64,0x6d,0x6f,0x6e,0x64,0x2e,0x63,0x6f,0x72,0x70,0x2e,0x6d,0x69,0x63,0x72,
    0x6f,0x73,0x6f,0x66,0x74,0x2e,0x63,0x6f,0x6d,0x5c,0x43,0x65,0x72,0x74,0x45,0x6e,
    0x72,0x6f,0x6c,0x6c,0x5c,0x64,0x73,0x73,0x70,0x73,0x76,0x72,0x34,0x63,0x61,0x32,
    0x2e,0x72,0x65,0x64,0x6d,0x6f,0x6e,0x64,0x2e,0x63,0x6f,0x72,0x70,0x2e,0x6d,0x69,
    0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x2e,0x63,0x6f,0x6d,0x5f,0x53,0x48,0x45,0x44,
    0x56,0x65,0x6e,0x64,0x6f,0x72,0x54,0x65,0x73,0x74,0x43,0x41,0x2e,0x63,0x72,0x74,
    0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x05,0x05,0x00,0x03,
    0x82,0x01,0x01,0x00,0x19,0xba,0x07,0xd4,0x13,0x3b,0x66,0x16,0x9c,0x8e,0x22,0x37,
    0xbb,0xea,0x09,0x5d,0x7c,0x2b,0xf7,0x53,0x47,0x97,0xee,0xca,0x47,0xdc,0xe5,0xdb,
    0xc2,0x4d,0x28,0xff,0x88,0xa0,0xb7,0xf7,0x3f,0x16,0x24,0xe8,0x96,0xfa,0xf0,0x2c,
    0x2a,0x29,0x7a,0x2a,0x0f,0x8e,0x5a,0x53,0xe1,0x4a,0xca,0xb5,0x9d,0xf5,0x09,0x90,
    0x4d,0x1f,0x83,0xd7,0x3b,0x79,0x45,0x33,0x85,0x77,0x98,0xac,0xcd,0x73,0xae,0x0f,
    0x06,0x53,0xb5,0xad,0xfb,0x2b,0xb5,0x6f,0x03,0xc9,0x7c,0xf7,0x96,0xe5,0x7b,0x40,
    0xfe,0xc5,0xb5,0x04,0xc3,0x5d,0xf6,0x0a,0xd6,0x48,0x2d,0x3b,0x82,0x73,0x33,0xa1,
    0xb8,0x35,0xb1,0x9f,0xdf,0x65,0xd2,0x85,0xc8,0x8f,0x32,0x2e,0x26,0xb8,0xab,0x0b,
    0x59,0xa3,0x67,0x84,0xa2,0xe8,0xfc,0x75,0xfa,0x01,0xb3,0xae,0x08,0x4e,0x01,0xf7,
    0xf7,0x38,0x2c,0xf2,0x3d,0xe1,0xbd,0xb7,0xc5,0x4f,0x7b,0x7c,0x0a,0xba,0x03,0x56,
    0x89,0xd4,0x89,0x0f,0xbd,0x91,0xcb,0x3e,0x4e,0xa5,0x10,0x2b,0xe0,0xa3,0x6c,0x60,
    0x55,0x79,0xf2,0x84,0x05,0xcf,0x5e,0x64,0xc6,0x87,0x77,0x56,0x8b,0xe8,0x39,0xb7,
    0xb0,0x64,0xdf,0xe6,0x55,0x83,0xbb,0xfa,0xbc,0x4c,0xb7,0x3e,0x36,0x71,0x79,0x31,
    0xbf,0xba,0x21,0x3b,0xb1,0x93,0xb9,0xdb,0xc1,0xb7,0x0b,0xb9,0x74,0x3e,0xef,0x2b,
    0x81,0x38,0xc7,0xce,0xd4,0xb9,0x48,0xd6,0x55,0x1e,0x44,0xa2,0x39,0x8b,0x40,0xb4,
    0xd4,0x2f,0xec,0x38,0x11,0xff,0xda,0x63,0xe6,0x4f,0x3c,0xae,0xc6,0x72,0xc4,0x59,
    0xfe,0xa6,0xa7,0x62,0x30,0x82,0x03,0x4e,0x30,0x82,0x02,0x36,0xa0,0x03,0x02,0x01,
    0x02,0x02,0x10,0x27,0xbb,0x4e,0x03,0xf6,0x68,0xa8,0x9f,0x4c,0x2e,0x58,0x2e,0x25,
    0x4b,0x26,0x54,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x05,
    0x05,0x00,0x30,0x27,0x31,0x25,0x30,0x23,0x06,0x03,0x55,0x04,0x03,0x13,0x1c,0x4d,
    0x53,0x20,0x50,0x72,0x6f,0x74,0x65,0x63,0x74,0x65,0x64,0x20,0x4d,0x65,0x64,0x69,
    0x61,0x20,0x54,0x65,0x73,0x74,0x20,0x52,0x6f,0x6f,0x74,0x30,0x1e,0x17,0x0d,0x30,
    0x35,0x30,0x37,0x31,0x35,0x30,0x32,0x30,0x38,0x31,0x31,0x5a,0x17,0x0d,0x31,0x31,
    0x30,0x33,0x30,0x36,0x31,0x38,0x30,0x30,0x31,0x31,0x5a,0x30,0x27,0x31,0x25,0x30,
    0x23,0x06,0x03,0x55,0x04,0x03,0x13,0x1c,0x4d,0x53,0x20,0x50,0x72,0x6f,0x74,0x65,
    0x63,0x74,0x65,0x64,0x20,0x4d,0x65,0x64,0x69,0x61,0x20,0x54,0x65,0x73,0x74,0x20,
    0x52,0x6f,0x6f,0x74,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,
    0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,
    0x02,0x82,0x01,0x01,0x00,0xbc,0xac,0xaf,0xf1,0x2b,0xe9,0x87,0x7f,0x31,0x09,0x94,
    0x63,0x0f,0x48,0x30,0x12,0xc1,0x6b,0xea,0x7e,0x0e,0xfc,0x58,0xb8,0xc8,0x90,0xf3,
    0xc7,0x71,0x9f,0x41,0xb5,0xbb,0x29,0xe3,0x83,0x47,0x35,0xbf,0x42,0xde,0x7a,0x9c,
    0xc1,0x6d,0x12,0x50,0x94,0x06,0x1e,0x72,0x1b,0x6f,0xf8,0xc0,0x20,0x7f,0xdf,0x6d,
    0xad,0x84,0x0f,0x08,0xbb,0x9a,0x3f,0x93,0x58,0x9d,0x93,0x1f,0x05,0xb6,0x40,0xab,
    0x87,0x8c,0x7f,0xaa,0x4f,0x03,0x3d,0x7d,0xfa,0x6b,0x3b,0xbc,0xfb,0xe0,0xc4,0x26,
    0xb0,0x17,0x3e,0xb6,0x7e,0xcc,0x9d,0x08,0x98,0x75,0x66,0x7a,0x34,0xaf,0x18,0x9b,
    0x3d,0x2c,0xce,0xfc,0xd9,0x43,0x59,0x91,0x97,0xf3,0x93,0x32,0x55,0xb7,0xda,0x32,
    0x8a,0xda,0xde,0x68,0x26,0xc3,0x0c,0x6f,0x7e,0xab,0x43,0x4c,0xf5,0xc0,0x0a,0x22,
    0xfd,0x5b,0x47,0xa7,0xa9,0x96,0x46,0x17,0x52,0x9f,0xbb,0x3b,0x1d,0x85,0x0a,0x90,
    0xcd,0x81,0x81,0x05,0x34,0x2b,0xca,0x43,0xc2,0x90,0x75,0x57,0x4d,0x61,0x51,0xc0,
    0xd6,0xd2,0x64,0x8c,0x41,0x21,0x07,0xbe,0x5c,0x82,0x4a,0x4f,0x94,0x51,0x08,0x75,
    0x22,0xb9,0xae,0xb9,0x48,0x28,0xf7,0xc7,0x86,0x06,0x04,0x0b,0x70,0x11,0xf0,0xcd,
    0xcd,0xa0,0x79,0xd3,0xce,0x9c,0xc5,0x36,0x7c,0x57,0x9b,0xb6,0xdf,0x5b,0x83,0xbe,
    0x61,0x6b,0xe2,0x58,0xd2,0xd9,0x85,0x8d,0x7e,0xe1,0xa4,0x46,0x57,0x46,0x61,0xf9,
    0xdf,0x4f,0x82,0xb9,0xac,0x8f,0xd2,0xdf,0xef,0x60,0x82,0xec,0x12,0x72,0xbf,0x14,
    0xd2,0x0a,0xcc,0xaf,0x3f,0x02,0x03,0x01,0x00,0x01,0xa3,0x76,0x30,0x74,0x30,0x0b,
    0x06,0x03,0x55,0x1d,0x0f,0x04,0x04,0x03,0x02,0x01,0x86,0x30,0x0f,0x06,0x03,0x55,
    0x1d,0x13,0x01,0x01,0xff,0x04,0x05,0x30,0x03,0x01,0x01,0xff,0x30,0x1d,0x06,0x03,
    0x55,0x1d,0x0e,0x04,0x16,0x04,0x14,0xcb,0x34,0xa7,0x04,0x7d,0xa7,0x62,0xba,0x85,
    0x2f,0x28,0xfa,0xa7,0x58,0x33,0xfa,0x99,0x50,0xda,0xce,0x30,0x10,0x06,0x09,0x2b,
    0x06,0x01,0x04,0x01,0x82,0x37,0x15,0x01,0x04,0x03,0x02,0x01,0x01,0x30,0x23,0x06,
    0x09,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x15,0x02,0x04,0x16,0x04,0x14,0x95,0x1d,
    0xbf,0x0c,0x08,0xda,0xde,0x1d,0x56,0xd3,0xf8,0x38,0x9b,0x04,0xf6,0xe9,0x02,0x7a,
    0x61,0x34,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x05,0x05,
    0x00,0x03,0x82,0x01,0x01,0x00,0x1b,0xed,0x2d,0xe3,0x91,0x36,0xf3,0x08,0x21,0xe4,
    0x3f,0x13,0x1b,0x6f,0x98,0xe6,0xe3,0x62,0xf1,0xf2,0x71,0xb6,0x48,0x3d,0x62,0xcc,
    0xe9,0xb2,0xd0,0x29,0x3f,0xdf,0xea,0x0d,0xc1,0x03,0x54,0xda,0xfb,0x02,0x61,0x3b,
    0xee,0x18,0x91,0x2a,0x2c,0xf8,0xd3,0x4f,0xe3,0xf6,0xfc,0xa5,0x61,0xe9,0xbf,0x9c,
    0xb6,0xa2,0x57,0xa5,0x37,0x7d,0x1e,0xab,0x08,0x66,0xd5,0x5a,0x2c,0x9a,0xc1,0x31,
    0x8d,0x65,0xa7,0xd2,0xbe,0xa8,0x0e,0xc7,0x42,0x4a,0x29,0x6e,0x4c,0xe4,0xf5,0xb9,
    0xec,0xee,0x63,0xbd,0x81,0x32,0x1a,0xc8,0x28,0x77,0xb0,0x20,0x03,0xfc,0xb0,0xda,
    0x13,0xc0,0x74,0xc9,0xef,0x74,0x04,0xe8,0x95,0x7a,0xe3,0x85,0x16,0xc6,0xa9,0x51,
    0x23,0xba,0x4f,0xb0,0x9f,0x01,0x4a,0x07,0x3b,0xa6,0x5b,0x7f,0x6f,0xc0,0xda,0xfe,
    0x90,0xa2,0x72,0xc1,0xbf,0x11,0x53,0x6b,0xc7,0xea,0x7d,0xee,0x28,0x96,0xc7,0x6a,
    0x31,0x64,0x91,0x94,0xef,0x7d,0xda,0xbd,0x80,0x94,0x60,0xf2,0x4f,0xee,0x98,0xf0,
    0xde,0xcd,0x5d,0x03,0x05,0x09,0xb0,0x2f,0x9b,0x25,0x2b,0xd0,0xc3,0xd9,0x3f,0xc7,
    0x7b,0x4c,0x2b,0xdb,0x6e,0x06,0x19,0x3d,0xb1,0xec,0x53,0x07,0x15,0x51,0x9f,0xd6,
    0x3e,0xf2,0xee,0xd8,0x59,0x1d,0xae,0xdc,0x13,0x2d,0x8e,0xa5,0x77,0x8f,0x5e,0x97,
    0x5f,0x95,0x6d,0x9f,0xd6,0xb0,0x78,0x41,0x4f,0x62,0xef,0x8b,0xce,0x72,0xa4,0x38,
    0xba,0xae,0x1d,0xe8,0x7b,0xac,0xbc,0x95,0x05,0x09,0x82,0x01,0xad,0x56,0x70,0x39,
    0x85,0x1d,0xb3,0x3f,0x09,0xd9,0x30,0x82,0x04,0x00,0x30,0x82,0x02,0xe8,0xa0,0x03,
    0x02,0x01,0x02,0x02,0x0a,0x61,0x16,0xaf,0x11,0x00,0x01,0x00,0x00,0x00,0x45,0x30,
    0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x05,0x05,0x00,0x30,0x27,
    0x31,0x25,0x30,0x23,0x06,0x03,0x55,0x04,0x03,0x13,0x1c,0x4d,0x53,0x20,0x50,0x72,
    0x6f,0x74,0x65,0x63,0x74,0x65,0x64,0x20,0x4d,0x65,0x64,0x69,0x61,0x20,0x54,0x65,
    0x73,0x74,0x20,0x52,0x6f,0x6f,0x74,0x30,0x1e,0x17,0x0d,0x30,0x38,0x30,0x34,0x32,
    0x35,0x30,0x33,0x33,0x35,0x30,0x39,0x5a,0x17,0x0d,0x30,0x39,0x30,0x34,0x32,0x35,
    0x30,0x33,0x34,0x35,0x30,0x39,0x5a,0x30,0x7a,0x31,0x13,0x30,0x11,0x06,0x0a,0x09,
    0x92,0x26,0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x03,0x63,0x6f,0x6d,0x31,0x19,
    0x30,0x17,0x06,0x0a,0x09,0x92,0x26,0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x09,
    0x6d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x31,0x14,0x30,0x12,0x06,0x0a,0x09,
    0x92,0x26,0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,0x04,0x63,0x6f,0x72,0x70,0x31,
    0x17,0x30,0x15,0x06,0x0a,0x09,0x92,0x26,0x89,0x93,0xf2,0x2c,0x64,0x01,0x19,0x16,
    0x07,0x72,0x65,0x64,0x6d,0x6f,0x6e,0x64,0x31,0x19,0x30,0x17,0x06,0x03,0x55,0x04,
    0x03,0x13,0x10,0x53,0x48,0x45,0x44,0x56,0x65,0x6e,0x64,0x6f,0x72,0x54,0x65,0x73,
    0x74,0x43,0x41,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,
    0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,
    0x82,0x01,0x01,0x00,0xd8,0x24,0xa8,0x3f,0x55,0x36,0x6e,0xfc,0x6a,0x95,0x70,0x6c,
    0xa0,0xee,0xdd,0x89,0x02,0xfe,0xc6,0x0e,0x21,0xc7,0x91,0x79,0x5d,0xe3,0xd6,0x02,
    0x11,0x40,0xb8,0x87,0xbf,0x39,0xb7,0x0f,0x7c,0x17,0x7d,0xb4,0xe6,0xff,0x9c,0xfa,
    0xfb,0x61,0x7d,0xd9,0x2c,0xee,0xbf,0xe5,0x92,0x5f,0x46,0x10,0xe5,0xc8,0xe8,0xfe,
    0x3e,0xa0,0xae,0x40,0xdb,0x39,0xa2,0xe5,0x6e,0xaa,0x9d,0xf6,0x2f,0xd2,0x0b,0x05,
    0x10,0x4e,0xc0,0x38,0x42,0xf8,0xce,0x1e,0xeb,0x42,0xd5,0xa4,0x6e,0xcb,0x8b,0xe2,
    0xf2,0xf4,0x02,0x39,0x71,0x9b,0x70,0xdb,0x90,0xcd,0xa5,0x1e,0xbe,0xa1,0x52,0x4f,
    0xb6,0x3e,0x15,0x0d,0x3d,0x2f,0x28,0xa5,0x08,0x4c,0xad,0xfe,0x8a,0x23,0xaa,0x87,
    0x18,0x73,0x30,0x7f,0x7c,0x74,0xb0,0xe8,0xad,0x31,0x65,0x87,0xe1,0x39,0x9e,0x29,
    0x16,0xe4,0x05,0xed,0xeb,0x24,0x53,0x49,0x07,0xa2,0xc6,0xdf,0x52,0x7f,0x93,0x9f,
    0x19,0x50,0xaa,0x55,0x71,0x53,0x15,0xba,0x9e,0x17,0xba,0x43,0xdc,0xc8,0xa0,0xc6,
    0xef,0x47,0xcc,0xa0,0xe0,0xf7,0xaf,0x13,0x40,0x55,0x26,0x72,0x2f,0xd1,0x92,0x77,
    0xd9,0x9b,0xc3,0x25,0x2f,0xbe,0x60,0xd0,0x70,0x54,0x0e,0x79,0x17,0xf1,0xa5,0x76,
    0x38,0xab,0xf3,0x53,0x89,0xef,0xa1,0x02,0xdc,0x5b,0xda,0x91,0xc8,0x70,0xfa,0x6d,
    0x24,0x52,0x81,0xc7,0x45,0x21,0x96,0x7d,0xb5,0x3c,0xdc,0x31,0x6f,0xe6,0x6e,0xbe,
    0x77,0x86,0xe4,0x8b,0xba,0x66,0x94,0x93,0x34,0x9e,0x4c,0xeb,0x2a,0xd0,0x47,0x23,
    0x4f,0x9a,0xac,0x55,0x02,0x03,0x01,0x00,0x01,0xa3,0x81,0xda,0x30,0x81,0xd7,0x30,
    0x0f,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x05,0x30,0x03,0x01,0x01,0xff,
    0x30,0x1d,0x06,0x03,0x55,0x1d,0x0e,0x04,0x16,0x04,0x14,0x97,0xf8,0x87,0x7c,0xd3,
    0x45,0xb8,0x0a,0xff,0x63,0xc5,0xdf,0x50,0x13,0x6a,0xf7,0xa7,0x9d,0x50,0x79,0x30,
    0x0b,0x06,0x03,0x55,0x1d,0x0f,0x04,0x04,0x03,0x02,0x01,0x86,0x30,0x10,0x06,0x09,
    0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x15,0x01,0x04,0x03,0x02,0x01,0x00,0x30,0x19,
    0x06,0x09,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x14,0x02,0x04,0x0c,0x1e,0x0a,0x00,
    0x53,0x00,0x75,0x00,0x62,0x00,0x43,0x00,0x41,0x30,0x1f,0x06,0x03,0x55,0x1d,0x23,
    0x04,0x18,0x30,0x16,0x80,0x14,0xcb,0x34,0xa7,0x04,0x7d,0xa7,0x62,0xba,0x85,0x2f,
    0x28,0xfa,0xa7,0x58,0x33,0xfa,0x99,0x50,0xda,0xce,0x30,0x29,0x06,0x09,0x2b,0x06,
    0x01,0x04,0x01,0x82,0x37,0x15,0x0a,0x04,0x1c,0x30,0x1a,0x30,0x0a,0x06,0x08,0x2b,
    0x06,0x01,0x05,0x05,0x07,0x03,0x03,0x30,0x0c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,
    0x82,0x37,0x0a,0x05,0x0a,0x30,0x1f,0x06,0x03,0x55,0x1d,0x25,0x04,0x18,0x30,0x16,
    0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x03,0x03,0x06,0x0a,0x2b,0x06,0x01,0x04,
    0x01,0x82,0x37,0x0a,0x05,0x0a,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,
    0x01,0x01,0x05,0x05,0x00,0x03,0x82,0x01,0x01,0x00,0x3d,0x8a,0xa2,0x8f,0x74,0xa8,
    0x3e,0xd5,0xeb,0x51,0x93,0x16,0x68,0x21,0xab,0x3d,0xc0,0xda,0x34,0xc0,0x8f,0x88,
    0x4b,0x9e,0xd5,0xda,0x30,0x55,0x0f,0xbc,0x9c,0xca,0x47,0xf3,0xcf,0x4f,0x59,0xe5,
    0x81,0xda,0xc0,0xbc,0x65,0x5e,0x99,0xac,0x30,0xb9,0xae,0x9a,0x39,0x55,0xc4,0xc4,
    0x56,0xde,0x05,0x94,0x29,0x60,0x66,0x8c,0x34,0x21,0x0f,0xa6,0xf6,0xd3,0x05,0xa7,
    0xff,0x14,0x0b,0xbb,0x13,0x02,0xb2,0xed,0x64,0xa7,0x49,0x30,0x36,0x7b,0xfd,0xa1,
    0x78,0x69,0x0e,0xe2,0x1c,0x62,0xdd,0xb8,0x82,0x9b,0xb4,0x0e,0x33,0x26,0xba,0x8c,
    0x2e,0x7d,0x90,0x74,0xc5,0xfc,0xb1,0xe0,0x28,0xeb,0xf5,0x93,0x3c,0x18,0x70,0x72,
    0x1c,0x04,0x6f,0x4d,0x38,0x54,0x88,0x1b,0x8e,0x75,0x24,0x6d,0x76,0x55,0x2c,0x48,
    0xf7,0x70,0xd8,0xb6,0x88,0x65,0x77,0x6d,0x2d,0x88,0x70,0xfb,0x1e,0x9c,0x3c,0x0e,
    0xef,0x41,0xff,0x71,0xaf,0x46,0x30,0x10,0x32,0xb0,0xa6,0x98,0x18,0xbd,0xd6,0x18,
    0x29,0x0f,0xeb,0xf5,0x3f,0x3d,0x08,0x44,0x8d,0xc7,0x90,0xa7,0x05,0xb3,0xff,0x58,
    0x0c,0x20,0x33,0x96,0xf9,0xab,0xa9,0x66,0x11,0xd8,0x2d,0x3d,0x3a,0x1e,0x43,0xac,
    0x19,0x33,0x8e,0xbb,0x7f,0x4e,0xa3,0xe7,0x6c,0x23,0xcd,0x25,0x75,0x75,0x8c,0x23,
    0x19,0x62,0xbf,0x24,0xfb,0x9e,0xf8,0xb4,0xe0,0xff,0x7f,0xb4,0xd5,0x02,0x77,0x0b,
    0x40,0x40,0xe7,0x08,0x46,0x7c,0x02,0x8e,0x63,0x02,0x77,0x5e,0x7f,0x2a,0x55,0x79,
    0x7b,0x0f,0x98,0x44,0x88,0xe6,0x79,0x02,0x4f,0xef,0x31,0x00
};
#endif //_TESTCERT_H_
```
