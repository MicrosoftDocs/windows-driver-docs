---
title: Using Avc.sys
description: Using Avc.sys
keywords:
- Avc.sys function driver WDK , about Avc.sys function driver
- AV/C WDK , Avc.sys usage
- subunit support WDK AV/C
ms.date: 04/20/2017
---

# Using Avc.sys





After Windows loads and initializes *Avc.sys*, *Avc.sys* uses standard AV/C unit and subunit commands to discover the active subunits on all AV/C devices connected to the IEEE 1394 bus (including any virtual subunits when the computer is a virtual AV/C unit). *Avc.sys* then generates device identifiers (IDs) for all of the active subunits. Next, *Avc.sys* uses standard Plug and Play (PnP) mechanisms to load the appropriate subunit driver for each subunit. The subunit driver to be loaded is selected based on the INF file that installs the subunit driver, and the subunit's device identifier, as generated by *Avc.sys* and described in [AV/C Device IDs](av-c-device-identifiers.md). The device identifier is generated from the unit information of the AV/C device, in combination with the subunit's ***SubunitType*** and ***SubunitID*** fields. The driver that supports a subunit can be vendor-specific, or it can be generic for the type of subunit. For example, the subunit driver for most DV camcorders is the Microsoft-provided *Msdv.sys*.

Subunit drivers communicate with *Avc.sys* through the standard IRP-based mechanism employed by all drivers based upon the WDM architecture. A subunit driver communicates with its AV/C subunit by allocating and sending IRPs down the driver stack to the AV/C protocol driver, *Avc.sys*. To make I/O requests, include the header file *Avc.h*, which is shipped with the Microsoft Windows Driver Kit (WDK).

A subunit driver allocates and initializes IRPs to be processed by *Avc.sys*. A subunit driver sets the IRP's **Parameters.DeviceIoControl.IoControlCode** member to the IOCTL that corresponds to the desired AV/C operation.

*Avc.sys* registers one of two [device interfaces](/windows-hardware/drivers/ddi/index), depending upon which subunit driver stack that it was loaded to support (peer or virtual). These interfaces define the functionality that *Avc.sys* exports for subunit drivers, other drivers, and applications to use. *Avc.sys* then changes the interface's state to enabled or disabled according to the driver's PnP state.

*Avc.sys* registers a new instance of GUID\_AVC\_CLASS if it was loaded to provide support for external AV/C subunits (the peer stack). This interface supports only the following I/O control (IOCTL) code:

-   [**IOCTL\_AVC\_CLASS**](/windows-hardware/drivers/ddi/avc/ni-avc-ioctl_avc_class)

IOCTL\_AVC\_CLASS in turn supports multiple function codes. Child drivers of instances of *Avc.sys* to support peer subunits are guaranteed to have access to this interface through their parent device object.

The GUID\_AVC\_CLASS interface supports all IOCTL\_AVC\_CLASS function codes, although some have limitations on their use, as described in the reference pages for each function.

*Avc.sys* registers a new instance of GUID\_VIRTUAL\_AVC\_CLASS, if it was loaded, to provide support for virtual AV/C subunits (the virtual stack). This interface supports four I/O control (IOCTL) codes:

-   [**IOCTL\_AVC\_CLASS**](/windows-hardware/drivers/ddi/avc/ni-avc-ioctl_avc_class)

-   [**IOCTL\_AVC\_UPDATE\_VIRTUAL\_SUBUNIT\_INFO**](/windows-hardware/drivers/ddi/avc/ni-avc-ioctl_avc_update_virtual_subunit_info)

-   [**IOCTL\_AVC\_REMOVE\_VIRTUAL\_SUBUNIT\_INFO**](/windows-hardware/drivers/ddi/avc/ni-avc-ioctl_avc_remove_virtual_subunit_info)

-   [**IOCTL\_AVC\_BUS\_RESET**](/windows-hardware/drivers/ddi/avc/ni-avc-ioctl_avc_bus_reset)

The GUID\_VIRTUAL\_AVC\_CLASS interface does not support every IOCTL\_AVC\_CLASS function code. The reference page for each individual function code specifies whether it is supported for GUID\_VIRTUAL\_AVC\_CLASS instances of *Avc.sys*.

IOCTL\_AVC\_CLASS IRPs are only supported in kernel mode (generally for driver-to-driver communication) through [**IRP\_MJ\_INTERNAL\_DEVICE\_CONTROL**](../kernel/irp-mj-internal-device-control.md). Therefore, applications cannot directly access the functions provided by the IOCTL\_AVC\_CLASS IOCTL code.

The last three IOCTL codes are supported in both kernel-mode and user-mode through [**IRP\_MJ\_DEVICE\_CONTROL**](../kernel/irp-mj-device-control.md). This means that applications can send these IOCTLs directly to *Avc.sys*.

The IOCTL\_AVC\_CLASS IOCTL code must always be accompanied by an I/O request block (IRB), which further describes the AV/C operation to perform. The IRB header includes a function number, which determines the structure of the rest of the IRB. The IRB structure and size varies according to the function. *Avc.sys* uses two custom IRBs:

-   [**AVC\_COMMAND\_IRB**](/windows-hardware/drivers/ddi/avc/ns-avc-_avc_command_irb)

-   [**AVC\_MULTIFUNC\_IRB**](/windows-hardware/drivers/ddi/avc/ns-avc-_avc_multifunc_irb)

The choice of which IRB a subunit driver must use depends on the desired function. For more information about the IOCTL\_AVC\_CLASS function codes supported by *Avc.sys,* see [AV/C Protocol Driver Function Codes](./av-c-protocol-driver-function-codes.md).

The primary AV/C function used by subunit drivers is [**AVC\_FUNCTION\_COMMAND**](./avc-function-command.md), which uses the AVC\_COMMAND\_IRB structure. **AVC\_FUNCTION\_COMMAND** sends AV/C requests and receives the corresponding AV/C responses. Details for building AV/C commands are handled by *Avc.sys*, but the subunit driver must provide the AV/C opcode and operands of each command.

 

